{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"petisco \ud83c\udf6a","text":""},{"location":"#what-is-petisco","title":"What is petisco?","text":"<p><code>petisco</code> is a framework for helping Python developers to build clean Applications in Python.</p>"},{"location":"#how-could-petisco-help-me","title":"How could petisco help me?","text":"<p><code>petisco</code> provides several handy classes to help you on defining your domain with hexagonal architecture, event streaming and CQRS.</p>"},{"location":"acknowledgements/","title":"Acknowledgements","text":"<p>Thanks to:</p> <ul> <li>Fer for planting the seed of DDD in our team. \ud83e\udd18</li> <li>Dani for helping us with RabbitMQ and Queue Management. \ud83d\udc4c</li> <li>CodelyTv for guiding us with their fantasy in their audiovisual content and their impressive examples in their public repositories. &lt;\ud83c\udf4d&gt;</li> <li>Carlos Buenosvinos for your wonderful content that has helped us understand many messaging concepts and lead the way in the world of CQRS.  \ud83d\ude80</li> </ul>"},{"location":"application/","title":"Application","text":"<p>Let's go deeper into the application layer.</p> <pre><code>flowchart LR\n\n        subgraph I/O\n            cli([CLI])\n            webapp([Web App])\n            message([Message Broker])\n        end\n\n        subgraph Application\n            dic([Container])        \n            dic-- Dependency Injection --&gt;usecase\n            controller([Controller])\n            usecase([UseCase])\n            subscriber([Subscriber])\n            controller --&gt; usecase\n            subscriber --&gt; usecase\n        end\n\n        webapp --&gt; controller\n        cli --&gt; controller\n        message --&gt; subscriber\n\n        subgraph Domain\n        petisco(((petisco)))\n        end\n\n        usecase --&gt; petisco\n\n        subgraph Infrastructure\n            Persistence[(Persistence)]\n            petisco --&gt; Persistence\n            petisco --&gt; Buses\n            petisco --&gt; Monitoring\n            petisco --&gt; Others\n        end\n\n        style Application fill:#D6EAF8</code></pre>"},{"location":"application/#dependency-injection-container","title":"Dependency Injection Container","text":"<p>The framework provides a Dependency Injection Container to manage instantiation and configuration of dependencies.</p> <pre><code>flowchart LR\n\n        subgraph I/O\n            cli([CLI])\n            webapp([Web App])\n            message([Message Broker])\n        end\n\n\n\n        subgraph Application\n            dic([Container])        \n            dic-- Dependency Injection --&gt;usecase\n            controller([Controller])\n            usecase([UseCase])\n            subscriber([Subscriber])\n            controller --&gt; usecase\n            subscriber --&gt; usecase\n        end\n\n        webapp --&gt; controller\n        cli --&gt; controller\n        message --&gt; subscriber\n\n        subgraph Domain\n        petisco(((petisco)))\n        end\n\n        usecase --&gt; petisco\n\n        subgraph Infrastructure\n            Persistence[(Persistence)]\n            petisco --&gt; Persistence\n            petisco --&gt; Buses\n            petisco --&gt; Monitoring\n            petisco --&gt; Others\n        end\n\n        style dic fill:#F0B27A\n        style Application fill:#D6EAF8</code></pre> <p>As we presented in the Getting Started section. The dependencies will be configured in the  <code>Container</code> when <code>Aplication</code> is configured. Once they are configured, we can instantiate defined implementations using the static method <code>get</code> from <code>Container</code>  object. <code>Controllers</code> and <code>Subscribers</code> (described below), instantiate collaborators of <code>UseCase</code>s using the <code>Container</code> object.</p> Usage <p>Accessing the container to instantiate its dependencies is as easy as following: To configure dependencies manually, use <code>set_dependencies</code>:</p> Defining DependenciesInstantiation of set Dependencies <pre><code>from petisco import Dependency, Container\n\ndependencies = [\n    Dependency(MyBase, builders={\"default\": Builder(MyImplementation)})\n]    \nContainer.set_dependencies(dependencies)\n</code></pre> <pre><code>from petisco import Container\n\nmy_instance = Container.get(MyBase)\n\n# You can check available dependencies\navailable_dependencies = Container.get_available_dependencies()\n</code></pre> <p>When defining dependencies, you can add different implementation on the builders as in the following code:</p> <pre><code>dependencies = [\n    Dependency(\n        MyBase, \n        builders={\n            \"default\": Builder(MyImplementation),\n            \"fake\": Builder(MyFakeImplementation),\n            \"inmemory\": Builder(MyInmemoryImplementation),\n        }\n    )\n]    \n</code></pre> <p>Warning</p> <p>\"default\" implementation is mandatory on <code>Dependency</code> definition, if it is not defined  it will raise an error in Runtime.</p> <p>Environment Modifiers: </p> <p>When you get the instance with <code>Container.get(MyBase)</code>, by default you will get an instance of default implementation defined in <code>builders</code>. </p> <p>If you want to modify this, you an do it with an environment variable (<code>&lt;NAME_OF_THE_BASE_TYPE&gt;</code> + <code>_TYPE</code>). For example, in the above class if we set the envar <code>MY_BASE_TYPE</code> to <code>fake</code> the <code>Container.get(MyBase)</code> will return <code>fake</code> implementation.</p> <p>Alias:</p> <p>Imagine you want to have available two different dependencies from the same base type. You can use the alias to tell apart between them in instatiation time.</p> <pre><code>dependencies = [\n    Dependency(\n        MyBase, \n        alias=\"implementation_1\",\n        builders={\n            \"default\": Builder(MyImplementation_1),\n        }\n    ),\n    Dependency(\n        MyBase, \n        alias=\"implementation_2\",\n        builders={\n            \"default\": Builder(MyImplementation_2),\n        }\n    )\n]    \n</code></pre> <p>Then, to instatiate them, you can use alias parameter in Container:</p> <pre><code>instance_1 = Container.get(MyBase, alias=\"implementation_1\")\ninstance_2 = Container.get(MyBase, alias=\"implementation_2\")\n</code></pre> <p>Validation:</p> <p>Petisco will vailidate all dependencies to check if given implementations are subclasses of base class. <code>MyBase</code>  in the following example:</p> <pre><code> Dependency(\n        MyBase, \n        builders={\n            \"default\": Builder(MyImplementation), # (1)\n        }\n    )\n</code></pre> <ol> <li>If the implementation is not a subclass of MyBase, petisco will raise a TypeError exception</li> </ol> strict=False <p>If you want to be more permissive with this strict mode of validation you can specify it in your Dependency  definition.</p> <pre><code>class MyImplementationFactory:\n    @staticmethod\n    def build() -&gt; MyImplementation:\n        # do your stuff\n        return MyImplementation()\n\nDependency(\n    MyBase, \n    builders={\n        \"default\": Builder(MyImplementationFactory, is_builder=True), \n    },\n    strict=False\n)\n</code></pre> Example with Controller <pre><code>from meiga import BoolResult\nfrom petisco import Container\nfrom petisco.extra.fastapi import FastAPIController\n\nfrom app.src.task.create.application.task_creator import TaskCreator\nfrom app.src.task.shared.domain.task import Task\n\n\nclass CreateTaskController(FastAPIController):\n    def execute(self, task: Task) -&gt; BoolResult:\n        task_creator = TaskCreator( # (1)\n            labeler=Container.get(TaskLabeler),\n            repository=Container.get(TaskRepository),\n            domain_event_bus=Container.get(DomainEventBus),\n        )\n        return task_creator.execute(task=task) # (2)\n</code></pre> <ol> <li>Instantiate an <code>UseCase</code> using dependencies from container (using its base type).</li> <li>Execute the <code>UseCase</code> passing external output.</li> </ol>"},{"location":"application/#use-case","title":"Use Case","text":"<p>The use case is a class that solves a part of your business logic. </p> <pre><code>flowchart LR\n\n        subgraph I/O\n            cli([CLI])\n            webapp([Web App])\n            message([Message Broker])\n        end\n\n        subgraph Application\n            dic([Container])        \n            dic-- Dependency Injection --&gt;usecase\n            controller([Controller])\n            usecase([UseCase])\n            subscriber([Subscriber])\n            controller --&gt; usecase\n            subscriber --&gt; usecase\n        end\n\n        webapp --&gt; controller\n        cli --&gt; controller\n        message --&gt; subscriber\n\n        subgraph Domain\n        petisco(((petisco)))\n        end\n\n        usecase --&gt; petisco\n\n        subgraph Infrastructure\n            Persistence[(Persistence)]\n            petisco --&gt; Persistence\n            petisco --&gt; Buses\n            petisco --&gt; Monitoring\n            petisco --&gt; Others\n        end\n\n        style usecase fill:#F0B27A\n        style Application fill:#D6EAF8</code></pre> <p>As shown above, a <code>UseCase</code> will be instantiated by a <code>Controller</code> or  a <code>Subscriber</code>.  Both will use the <code>Container</code>, to inject the dependencies.</p> Example of TaskCreator (instantiated in the Controller Example) <p>Following the Task Manager application example, there is a <code>TaskCreator</code> that labels the task using an application  service, saves the task through a repository and publishes a domain event using an event bus. The code could be as  follow:</p> <pre><code>from meiga import BoolResult, isSuccess\nfrom petisco import CrudRepository, DomainEventBus, UseCase\n\nfrom my_app import Task\n\nclass TaskCreated(DomainEvent): ...\n\nclass TaskCreator(UseCase):\n    def __init__(\n        self,\n        labeler: TaskLabeler,\n        repository: CrudRepository,\n        domain_event_bus: DomainEventBus,\n    ):\n        self.labeler = labeler\n        self.repository = repository\n        self.domain_event_bus = domain_event_bus\n\n    def execute(\n        self,\n        task: Task,\n    ) -&gt; BoolResult:\n        task = self.labeler.execute(task).unwrap_or_return()\n        self.repository.save(task).unwrap_or_return()\n        self.domain_event_bus.publish_list(task.pull_domain_events())\n        return isSuccess\n</code></pre>"},{"location":"application/#controller","title":"Controller","text":"<p>A controller is class which receive inputs from the infrastructure layer (web framework, cli, etc...) and orchestrate  the application use cases given a result. Use <code>Controller</code> class to define and configure inputs and outputs or your entry point. </p> <pre><code>flowchart LR\n\n        subgraph I/O\n            cli([CLI])\n            webapp([Web App])\n            message([Message Broker])\n        end\n\n\n\n        subgraph Application\n            dic([Container])        \n            dic-- Dependency Injection --&gt;usecase\n            controller([Controller])\n            usecase([UseCase])\n            subscriber([Subscriber])\n            controller --&gt; usecase\n            subscriber --&gt; usecase\n        end\n\n        webapp --&gt; controller\n        cli --&gt; controller\n        message --&gt; subscriber\n\n        subgraph Domain\n        petisco(((petisco)))\n        end\n\n        usecase --&gt; petisco\n\n        subgraph Infrastructure\n            Persistence[(Persistence)]\n            petisco --&gt; Persistence\n            petisco --&gt; Buses\n            petisco --&gt; Monitoring\n            petisco --&gt; Others\n        end\n\n        style controller fill:#F0B27A\n        style Application fill:#D6EAF8</code></pre> <p>You can use a simpler and default configuration:</p> <pre><code>from petisco import Controller\nfrom meiga import Result, Success, Error\nimport random\n\nclass MyController(Controller): # (1)\n    def execute(self) -&gt; Result[bool, Error]:\n        return Success(random.choice([True, False]))\n</code></pre> <ol> <li>Inherit from petisco Controller class</li> </ol>"},{"location":"application/#configuration","title":"Configuration","text":"<p>You can configure some behaviours with the inner class <code>Config</code>.  Configure controller <code>middlewares</code>, <code>success_handler</code> and <code>failure_handler</code>.</p> <pre><code>from petisco import DomainError, Controller, PrintMiddleware\nfrom meiga import Result, Success, Error\nimport random\n\nclass MyError(DomainError): ...\n\nclass MyController(Controller):\n    class Config: # (1)\n        success_handler = lambda result: {\"message\": \"ok\"}\n        error_map = {NotFound: HttpError(status_code=404, detail=\"Task not Found\")}\n        middlewares = [PrintMiddleware]\n\n    def execute(self) -&gt; Result[bool, Error]:\n        return Success(random.choice([True, False]))\n</code></pre> <ol> <li>By default, the failure handler uses the <code>error_map</code> to map error. But you can also config <code>failure_handler</code> as we do with <code>success_handler</code> callable. <pre><code>from petisco import DomainError, Controller, PrintMiddleware\nfrom meiga import Result, Success, Error\nimport random\n\nclass MyError(DomainError): ...\n\nclass MyController(Controller):\n    class Config:\n        success_handler = lambda result: {\"message\": \"ok\"}\n        failure_handler = lambda result: {\"message\": \"not ok\"} \n\n    def execute(self) -&gt; Result[bool, Error]:\n        return Success(random.choice([True, False]))\n</code></pre> </li> </ol> <p>Let's go into more detail in the following points.</p> <ul> <li> <p>Middlewares: are a layer of actions/callables that are wrapped around a piece of core logic in an application (in this case, the <code>Controller</code>)   <code>petisco</code> provides some examples of Middlewares:</p> Middleware Definition <code>PrintMiddleware</code> Print something before and after the controller <code>NotifierMiddleware</code> Notify a message if the result of a controller is a failure <p>Define your middleware</p> <p>To create your own Middleware is necessary to extend from <code>Middleware</code> as following code:</p> <pre><code>from meiga import Result\n\nfrom petisco import Middleware\n\n\nclass MyFirstMiddleware(Middleware):\n    def before(self):\n        print(\n            f\"{self.wrapped_class_name} -&gt; Start | Params {dict(self.wrapped_class_input_arguments)}\"\n        )\n\n    def after(self, result: Result):\n        print(f\"{self.wrapped_class_name} -&gt; End | {result}\")\n</code></pre> <p>Then, you can add it to your controller with:</p> <pre><code>class MyController(Controller):\n  class Config: \n    middlewares = [PrintMiddleware]\n\ndef execute(self) -&gt; Result[bool, Error]:\n    return Success(random.choice([True, False]))\n</code></pre> <p>Define the middleware scope (is it going to be used on Controller or/and Subscribers?)</p> <p>Example of Middleware to be used only in Controllers (<code>scope = MiddlewareScope.CONTROLLER</code>).</p> <pre><code>from petisco import MiddlewareScope\n\n\nclass MyScopedControllerMiddleware(Middleware):\n  scope = MiddlewareScope.CONTROLLER\n\n  def before(self) -&gt; None:\n      pass\n\n  def after(self, result: AnyResult) -&gt; None:\n      pass\n</code></pre> <p>Example of Middleware to be used only in Subscribers (<code>scope = MiddlewareScope.SUBSCRIBER</code>).</p> <pre><code>from petisco import MiddlewareScope\n\n\nclass MyScopedSubscriberMiddleware(Middleware):\n  scope = MiddlewareScope.SUBSCRIBER\n\n  def before(self) -&gt; None:\n      pass\n\n  def after(self, result: AnyResult) -&gt; None:\n      pass\n</code></pre> <p>If you want to use your middleware in Subscribers and Controllers you don't need to specify anything.</p> <pre><code>from petisco import MiddlewareScope\n\n\nclass MyGeneralMiddleware(Middleware):\n\n  def before(self) -&gt; None:\n      pass\n\n  def after(self, result: AnyResult) -&gt; None:\n      pass\n</code></pre> Do not use parametrized constructors on your Middlewares implementations <p>The following implementation is not valid:</p> <pre><code>from petisco import MiddlewareScope\n\n\nclass InvalidMiddleware(Middleware):\n  def __init__(self, my_fancy_parameter: str):\n      self.my_fancy_parameter = my_fancy_parameter\n\n  def before(self) -&gt; None:\n      pass\n\n  def after(self, result: AnyResult) -&gt; None:\n      pass\n</code></pre> <p>Configure <code>shared_middlewares</code> for all Controllers and Subscribers</p> <p>If you want to set a default middleware for every Controller and Subscriber, you can do it when defining your <code>Application</code> with the input <code>shared_middlewares</code></p> <pre><code>  from petisco.extra.fastapi import FastApiApplication\n\n  from app import (\n      APPLICATION_LATEST_DEPLOY,\n      APPLICATION_NAME,\n      APPLICATION_VERSION,\n      ORGANIZATION,\n  )\n  from app.fastapi import fastapi_configurer\n  from app.petisco.dependencies.dependencies import dependencies_provider\n\n  application = FastApiApplication(\n      name=APPLICATION_NAME,\n      version=APPLICATION_VERSION,\n      organization=ORGANIZATION,\n      deployed_at=APPLICATION_LATEST_DEPLOY,\n      dependencies_provider=dependencies_provider,\n      fastapi_configurer=fastapi_configurer,\n      shared_middlewares=[\n          NotifierMiddleware,\n          PrintMiddleware\n      ]\n  )\n</code></pre> Deprecated way for configuring middelwares with envar <p>There is also a deprecated way of configure shared middlewares using the envvar <code>PETISCO_DEFAULT_MIDDLEWARES</code>:</p> <p>* <code>PETISCO_DEFAULT_MIDDLEWARES=PrintMiddleware</code>: to configure PrintMiddleware</p> <p>* <code>PETISCO_DEFAULT_MIDDLEWARES=NotifierMiddleware</code>: to configure NotifierMiddleware</p> <p>* <code>PETISCO_DEFAULT_MIDDLEWARES=PrintMiddleware,NotifierMiddleware</code>: to configure several middlewares (using comma to separate)</p> </li> </ul> <ul> <li> <p>use_shared_middlewares: When you have middlewares configured through <code>shared_middlewares</code>, but you have some Controller/Subscriber that you don't want to be affected by they, you can use the field use_shared_middlewares and set it to <code>False</code> (default is <code>True</code>.</p> <pre><code>  class MyController(FastAPIController):\n      class Config:\n          use_shared_middlewares = False\n\n      def execute(self) -&gt; Result[dict, Error]:\n          ...\n</code></pre> <p>In that way the Controller/Subscriber only will be affected by the Middlewares defined in the Config (<code>MyNewMiddleware</code> in the below example).</p> <pre><code>class MyController(FastAPIController):\n    class Config:\n        middlewares = [MyNewMiddleware]\n        use_shared_middlewares = False\n\n    def execute(self) -&gt; Result[dict, Error]:\n        ...\n</code></pre> </li> </ul> <ul> <li>success_handler: you can modify the result of a controller when the result is a success with the <code>success_handler</code> Config argument.<pre><code>from petisco import DomainError, Controller, PrintMiddleware\nfrom meiga import Result, Success, Error\nimport random\n\nclass MyError(DomainError): ...\n\nclass MyController(Controller):\n    class Config:\n        success_handler = lambda result: {\"message\": f\"MyController set {result}\", \"detail\": \"whatever\"} \n\n    def execute(self) -&gt; Result[bool, Error]:\n        return Success(random.choice([True, False]))\n</code></pre> <p>If your want just to unwrap the success value of a Result (example above <code>Success(random.choice([True, False]))</code>)    just use the <code>unwrap_result_handler</code>.</p> <pre><code>from petisco import Controller, unwrap_result_handler\nfrom meiga import Result, Success, Error\nimport random\n\nclass MyController(Controller):\n    class Config:\n        success_handler = unwrap_result_handler\n\n    def execute(self) -&gt; Result[bool, Error]:\n        return Success(random.choice([True, False]))\n</code></pre> <p>Additionally, if you don't care about original result, for instance a <code>BoolResult</code>, you can define a custom message    with <code>custom_message_handler</code>:</p> <pre><code>from petisco import Controller, custom_message_handler\nfrom meiga import Result, Success, Error\nimport random\n\nclass MyController(Controller):\n    class Config:\n        success_handler = custom_message_handler({\"message\": \"my-custom-message}\")\n\n    def execute(self) -&gt; Result[bool, Error]:\n        return Success(random.choice([True, False]))\n</code></pre> </li> </ul> <ul> <li>failure_handler: you can modify the result of the controller when failure. <pre><code>from petisco import DomainError, Controller, PrintMiddleware\nfrom meiga import Result, Success, Failure, Error\nimport random\n\nclass MyError(DomainError): ...\n\nclass MyController(Controller):\n    class Config:\n        failure_handler = lambda result: {\"message\": f\"MyController error {result}\", \"detail\": \"random error\"} \n\n    def execute(self) -&gt; Result[bool, Error]:\n        if random.choice([True, False]) is False:\n            return Failure(MyError())\n        return Success(True)\n</code></pre> </li> </ul> <ul> <li> <p>error_map: you can define a mapping between <code>DomainError</code>s and HttpError using the <code>error_map</code> dictionary.</p> <pre><code>from petisco import DomainError, Controller, HttpError\nfrom meiga import Result, Success, Failure, Error\nimport random\n\nclass MyError(DomainError): ...\n\nclass MyController(Controller):\n    class Config:\n        error_map = {MyError: HttpError(status_code=400, detail=\"Random error\")}\n\n    def execute(self) -&gt; Result[bool, Error]:\n        if random.choice([True, False]) is False:\n            return Failure(MyError())\n        return Success(True)\n</code></pre> <p>Define shared error_map</p> <p>You can define a global shared error map to reuse in every controller of the application with:</p> <p>You can enhance your application's controllers by implementing a globally shared error map that can be utilized  across all controllers. This approach offers several benefits, such as improved code reusability and easier  management of error handling throughout the application. To implement this solution, consider the following steps:</p> <ul> <li>Create a shared error map: Define a dict with DomainErrors in keys and HttpErrors in values:</li> <li>Define the error map globally: Use the Application construction to define the shared error map.</li> </ul> <pre><code>from petisco import Application\nfrom datetime import datetime\n\nSHARED_ERROR_MAP: ErrorMap = {\n  MySharedNotFoundError: HttpError(status_code=404),\n  MySharedConflictError: HttpError(status_code=409)\n}\n\napplication = Application(\n    name=\"my-app\",\n    version=\"1.0.0\",\n    organization=\"acme\",\n    deployed_at=str(datetime.utcnow()),\n    shared_error_map=SHARED_ERROR_MAP,\n)\napplication.configure()\n</code></pre> <p>By implementing a global shared error map, you can streamline error management and foster efficient code reuse  among your application's controllers. This approach significantly improves maintainability and enables seamless future enhancements or modifications to error handling logic.</p> <p>Furthermore, even if you choose not to explicitly select an <code>error_map</code> in your controllers or application, there  are already default mappings available for you to leverage. For instance, you can make use of <code>petisco.DEFAULT_HTTP_ERROR_MAP</code>, which provides a set of predefined mappings for common HTTP errors.</p> <p><pre><code>DEFAULT_HTTP_ERROR_MAP: ErrorMap = {\n  DomainError: HttpError(status_code=500),\n  NotFound: HttpError(status_code=404),\n  AlreadyExists: HttpError(status_code=409),\n  AggregateNotFoundError: HttpError(status_code=404),\n  AggregatesNotFoundError: HttpError(status_code=404),\n  AggregateAlreadyExistError: HttpError(status_code=409),\n  ClientNotFound: HttpError(status_code=404),\n  ClientAlreadyExists: HttpError(status_code=409),\n  UserNotFound: HttpError(status_code=404),\n  UserAlreadyExists: HttpError(status_code=409),\n  InvalidUuid: HttpError(status_code=422),\n  InvalidValueObject: HttpError(status_code=500),\n}\n</code></pre> These default mappings serve as a solid foundation and can be customized as needed. If any specific error codes or messages need to be overridden or added, you can extend or modify the shared error map accordingly. This  flexibility allows you to tailor error handling to your application's unique requirements while still benefiting  from the convenience and consistency offered by the shared error map approach.</p> <p>Important \u26a0\ufe0f: When using petisco, it's essential to note that all defined error_maps, including the shared, default, and  controller ones, are internally merged. This merging process follows a specific priority order: controller  mappings take precedence over shared mappings, which in turn take precedence over default mappings. In practical terms, this means that if you define a key in the controller that is already defined in the shared  or default error_map, petisco will prioritize the value from the controller definition. This behavior ensures that you have full control over the error mappings within your specific controller, allowing you to override or  customize any predefined mappings as needed.</p> <p>By adhering to this merging priority, you can confidently manage and tailor error handling within your controllers  while leveraging the shared and default error maps for consistency and convenience. It empowers you to fine-tune  error mappings according to your application's requirements without sacrificing the benefits provided by petisco's  predefined error mappings.</p> </li> </ul>"},{"location":"application/#fastapi","title":"FastAPI \u26a1\ufe0f","text":"<p>To use it in combination with FastAPI is as easy as inherit from  <code>FastAPIController</code> instead of using <code>Controller</code> (as shown above).</p> <pre><code>from meiga import BoolResult\nfrom petisco import Container, DomainEventBus\nfrom petisco.extra.fastapi import FastAPIController\n\nfrom app.src.task.create.application.task_creator import TaskCreator\nfrom app.src.task.shared.domain.task import Task\n\n\nclass CreateTaskController(FastAPIController):\n    def execute(self, task: Task) -&gt; BoolResult:\n        task_creator = TaskCreator( # (1)\n            labeler=Container.get(TaskLabeler),\n            repository=Container.get(TaskRepository),\n            domain_event_bus=Container.get(DomainEventBus),\n        )\n        return task_creator.execute(task=task) # (2)\n</code></pre> <ol> <li>Defines and instantiate the use case.</li> <li>Executes the use case.</li> </ol> <p>Then, we have to instantiate and execute the controller object in the FastAPI routers.</p> <pre><code>from uuid import UUID\n\nfrom fastapi import APIRouter\nfrom petisco.extra.fastapi import as_fastapi\nfrom petisco import Uuid\n\n\nfrom app.api.models import TaskIn, TaskOut\nfrom app.src.task.create.application.create_task_controller import CreateTaskController\n\nrouter = APIRouter(tags=[\"Tasks\"])\n\n@router.post(\"/task\")\nasync def create_task(task: TaskIn):\n    result = CreateTaskController().execute(task.to_task()) # (1) \n    return as_fastapi(result) # (2) \n</code></pre> <ol> <li>Executes the Controller</li> <li>Transforms Result to FastAPI expected message or <code>HttpException</code>s.</li> </ol>"},{"location":"application/#subscriber","title":"Subscriber","text":"<p>A <code>Subscriber</code> is similar to <code>Controller</code>, use it to define and configure inputs and outputs or your entry point. The difference is that the <code>Subscriber</code> is executed reactively to messages (Domain Events, Commands, etc..).</p> <pre><code>flowchart LR\n\n        subgraph I/O\n            cli([CLI])\n            webapp([Web App])\n            message([Message Broker])\n        end\n\n        subgraph Application\n            dic([Container])        \n            dic-- Dependency Injection --&gt;usecase\n            controller([Controller])\n            usecase([UseCase])\n            subscriber([Subscriber])\n            controller --&gt; usecase\n            subscriber --&gt; usecase\n        end\n\n        webapp --&gt; controller\n        cli --&gt; controller\n        message --&gt; subscriber\n\n        subgraph Domain\n        petisco(((petisco)))\n        end\n\n        usecase --&gt; petisco\n\n        subgraph Infrastructure\n            Persistence[(Persistence)]\n            petisco --&gt; Persistence\n            petisco --&gt; Buses\n            petisco --&gt; Monitoring\n            petisco --&gt; Others\n        end\n\n        style subscriber fill:#F0B27A\n        style Application fill:#D6EAF8</code></pre> <p><code>Subscribers</code> (or handlers) are very useful on Event Streaming Architectures, where use cases publish domain events and subscribers handle them.</p> <ul> <li>Subscribe to all messages: If you want to create a subscriber to handle all the message, you have to extend from  <code>AllMessageSubscriber</code>.<pre><code>from petisco import AllMessageSubscriber, Message, Container\nfrom meiga import BoolResult\nfrom my_app import MessageSaver\n\nclass StoreMessage(AllMessageSubscriber):\n    def handle(self, message: Message) -&gt; BoolResult:\n        saver = MessageSaver(repository=Container.get(MessageRepository))\n        return saver.save(message)\n</code></pre> <p>In this example, the subscriber will handle all the messages and store them into a configured repository.</p> </li> </ul> <ul> <li>Subscribe to a DomainEvent: You can subscribe to domain events (check Domain to learn how to create a  domain event).<pre><code>flowchart LR\n\n        subgraph Use Case TaskCreator\n        eventbus([Event Bus])\n        end\n\n        message_broker([Message Broker])\n        eventbus -- Domain Event --&gt; message_broker\n        message_broker --  Domain Event --&gt; Subscriber\n\n        subgraph Use Case Send Notification \n        action([Action])\n        end\n\n        Subscriber --&gt; action\n\n        style Subscriber fill:#D6EAF8\n\n        style message_broker fill:#F0B27A,stroke:#333,stroke-width:2px</code></pre> </li> </ul> <p>Example subscribing to 1 Domain Event</p> <pre><code>from petisco import DomainEventSubscriber, DomainEvent, Container\nfrom my_app import TaskCreated, Notification, Notificator\n\nclass SendNotificationOnTaskCreated(DomainEventSubscriber):\n\n    def subscribed_to(self) -&gt; list[Type[DomainEvent]]: \n        return [TaskCreated] # (1)\n\n    def handle(self, domain_event: DomainEvent) -&gt; BoolResult:\n        notification = Notification.from_domain_event(domain_event)\n        notificator = Notificator(app_service=Container.get(MyAppService))\n        return notificator.execute(notification)\n</code></pre> <ol> <li>Defines which <code>DomainEvent</code> this subscriber will execute (In this case <code>TaskCreated</code>).</li> </ol> <p>Example subscribing to several Domain Events</p> <pre><code>flowchart LR\n\n        subgraph Use Case TaskCreator\n        eventbus1([Event Bus])\n        end\n\n        subgraph Use Case TaskUpdater\n        eventbus2([Event Bus])\n        end\n\n        subgraph Use Case TaskRemover\n        eventbus3([Event Bus])\n        end\n\n        message_broker([Message Broker])\n        eventbus1 -- TaskCreated --&gt; message_broker\n        eventbus2 -- TaskUpdated --&gt; message_broker\n        eventbus3 -- TaskRemoved --&gt; message_broker\n\n        message_broker --  TaskCreated --&gt; Subscriber\n        message_broker --  TaskUpdated --&gt; Subscriber\n        message_broker --  TaskRemoved --&gt; Subscriber \n\n        subgraph Use Case Send Notification \n        action([Action])\n        end\n\n        Subscriber --&gt; action\n\n        style Subscriber fill:#D6EAF8\n\n        style message_broker fill:#F0B27A,stroke:#333,stroke-width:2px</code></pre> <pre><code>from typing import Type\nfrom petisco import DomainEventSubscriber, DomainEvent, Container\nfrom my_app import TaskCreated, TaskUpdated, TaskRemoved, Notification, Notificator\n\nclass SendNotificationOnTaskModifications(DomainEventSubscriber):\n\n    def subscribed_to(self) -&gt; list[Type[DomainEvent]]:\n        return [TaskCreated, TaskUpdated, TaskRemoved] # (1)\n\n    def handle(self, domain_event: DomainEvent) -&gt; BoolResult:\n        notification = Notification.from_domain_event(domain_event)\n        notificator = Notificator(app_service=Container.get(MyAppService))\n        return notificator.execute(notification)\n</code></pre> <ol> <li>Defines which <code>DomainEvent</code> this subscriber will execute (In this case <code>TaskCreated</code>, <code>TaskUpdated</code>, <code>TaskRemoved</code>).</li> </ol> <ul> <li>Subscribe to a Command: You can subscribe to a command that is published by your domain.</li> </ul> Example <pre><code>from typing import Type\nfrom petisco import CommandSubscriber, Command, Container\nfrom my_app import CreateTask, TaskCreator\n\nclass CreateTaskOnCreateTaskCommand(CommandSubscriber):\n\n    def subscribed_to(self) -&gt; Type[Command]:\n        return [CreateTask] # (1)\n\n    def handle(self, command: Command) -&gt; BoolResult:\n        task = Task.from_command(command)\n         task_creator = TaskCreator(\n            repository=Container.get(TaskRepository),\n            domain_event_bus=self.domain_event_bus, # (2) \n        )\n        return task_creator.execute(task=task)  \n</code></pre> <ol> <li>Defines which <code>Command</code> this subscriber will execute (In this case <code>CreateTask</code>).</li> <li>Use available <code>domain_event_bus</code> in <code>CommandSubscriber</code> instead of <code>Container.get(DomainEventBus)</code></li> </ol> <p>Info</p> <p>For more info, take a look at Infrastructure/RabbitMQ and see how it works with a real implementation.</p>"},{"location":"application/#cqrs","title":"CQRS","text":"<p>CQRS (Command Query Responsibility Segregation) is incipient in petisco, but the framework already allows to play with  this architecture.  The following example presents the cases we have reviewed in the previous sections.  We will use a <code>Controller</code> to send a command over the command bus, so that a subscriber will receive this message and  instantiates the use case in order to complete the action.</p> <pre><code>flowchart LR\n\n        subgraph I/O\n        webapp([Web App])\n        end\n\n        subgraph Controller\n        command_bus([Command Bus])\n        end\n\n        subgraph Subscriber\n        subscriber_usecase([UseCase])\n        end\n\n        webapp -- Task --&gt; Controller\n        message_broker([Message Broker])\n        command_bus -- Command --&gt; message_broker\n        message_broker --  Command --&gt; Subscriber\n\n        style Controller fill:#D6EAF8\n        style Subscriber fill:#D6EAF8\n\n        style message_broker fill:#F0B27A,stroke:#333,stroke-width:2px\n</code></pre>"},{"location":"application/#fastapi_1","title":"FastAPI \u26a1\ufe0f","text":"<p>The following code is an example of how to use CQRS with petisco and FastAPI.</p> <pre><code>from typing import Type\n\nfrom fastapi import FastAPI\nfrom meiga import BoolResult, isSuccess\nfrom petisco.extra.fastapi import FastAPIController, as_fastapi\nfrom pydantic import BaseModel\nfrom pydantic.types import constr\nfrom petisco import CommandSubscriber, Command, Container, CommandBus\nfrom my_app import CreateTask, TaskCreator\n\napp = FastAPI()\n\n\nclass Task(BaseModel):\n    name: constr(max_length=50)\n    description: constr(max_length=200)\n\n\n# Controller\nclass CreateTaskController(FastAPIController):\n    def execute(self, task: Task) -&gt; BoolResult:\n        command_bus: CommandBus = Container.get(CommandBus)\n        create_task = CreateTask.from_task(task)\n        command_bus.dispatch(create_task)\n        return isSuccess\n\n\n# Subscriber\nclass CreateTaskOnCreateTaskCommandSubscriber(CommandSubscriber):\n\n    def subscribed_to(self) -&gt; Type[Command]:\n        return CreateTask\n\n    def handle(self, command: Command) -&gt; BoolResult:\n        task = Task.from_command(command)\n        task_creator = TaskCreator(\n            repository=Container.get(TaskRepository),\n            domain_event_bus=self.domain_event_bus, # (1)\n        )\n        return task_creator.execute(task=task)\n\n@app.post(\"/task\")\ndef create_task(task: Task):\n    result = CreateTaskController().execute(task)\n    return as_fastapi(result)\n</code></pre> <ol> <li>Use available <code>domain_event_bus</code> in <code>CommandSubscriber</code> instead of <code>Container.get(DomainEventBus\")</code></li> </ol>"},{"location":"asyncio/","title":"Asyncio","text":"<p>Petisco has several classes available to help you take advantage of the asyncio library. For example, the  AsyncController class provides a way to handle requests asynchronously, while the AsyncUseCase class offers an async  interface for implementing your business logic. These classes can be used to write highly performant and efficient code  that takes full advantage of the capabilities of the asyncio library.</p>"},{"location":"asyncio/#asyncappservice","title":"<code>AsyncAppService</code>","text":"<p>Inherit from <code>AsyncAppService</code> and don't forget to add <code>async</code> prefix before execution method.</p> <pre><code>from petisco import AsyncAppService\nfrom meiga import BoolResult, isSuccess\n\nclass MyAsyncAppService(AsyncAppService):\n    async def execute(self, my_input: str) -&gt; BoolResult:\n        return isSuccess\n</code></pre> <p>To call this app service, its necessary to await for it and call it from async function-</p> <pre><code>result = await MyAsyncAppService().execute\n</code></pre>"},{"location":"asyncio/#asyncusecase","title":"<code>AsyncUseCase</code>","text":"<p>Inherit from <code>AsyncUseCase</code> and don't forget to add <code>async</code> prefix before execution method.</p> <pre><code>from petisco import AsyncUseCase\nfrom meiga import BoolResult\n\n class MyUseCase(AsyncUseCase):\n\n    def __init__(self, app_service: MyAsyncAppService) -&gt; None:\n        self.app_service = app_service\n\n    async def execute(self) -&gt; BoolResult:\n        return await self.app_service.execute()\n</code></pre>"},{"location":"asyncio/#asynccontroller","title":"<code>AsyncController</code>","text":"<pre><code>from petisco import AsyncController\nfrom meiga import Result, Success, Error\nimport random\n\nclass MyController(AsyncController): # (1)\n    async def execute(self) -&gt; Result[bool, Error]:\n        return Success(random.choice([True, False]))\n</code></pre> <ol> <li>Inherit from petisco AsyncController class</li> </ol>"},{"location":"asyncio/#fastapi","title":"FastAPI \u26a1\ufe0f","text":"<p>Use <code>AsyncFastAPIController</code> instead of using <code>FastAPIController</code>.</p> <pre><code>from meiga import BoolResult\nfrom petisco import Container, DomainEventBus\nfrom petisco.extra.fastapi import AsyncFastAPIController\n\nfrom app.src.task.create.application.task_creator import TaskCreator\nfrom app.src.task.shared.domain.task import Task\n\n\nclass CreateTaskController(AsyncFastAPIController):\n    async def execute(self, task: Task) -&gt; BoolResult:\n        task_creator = TaskCreator(\n            labeler=Container.get(TaskLabeler),\n            repository=Container.get(TaskRepository),\n            domain_event_bus=Container.get(DomainEventBus),\n        )\n        return await task_creator.execute(task=task)\n</code></pre> <p>Then, we have to instantiate and execute the controller object in the FastAPI routers.</p> <pre><code>from uuid import UUID\n\nfrom fastapi import APIRouter\nfrom petisco.extra.fastapi import as_fastapi\nfrom petisco import Uuid\n\nfrom app.api.models import TaskIn, TaskOut\nfrom app.src.task.create.application.create_task_controller import CreateTaskController\n\nrouter = APIRouter(tags=[\"Tasks\"])\n\n@router.post(\"/task\")\nasync def create_task(task: TaskIn):\n    result = await CreateTaskController().execute(task.to_task())\n    return as_fastapi(result)\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>Review the Github Releases</p>"},{"location":"cli/","title":"CLI","text":"<p>This comprehensive guide aims to provide you with all the necessary information to effectively utilize the command-line  interface (CLI) tools offered by petisco. Whether you are a beginner or an experienced developer, this documentation  will help you harness the full potential of our CLI tools and streamline your development process.</p> <p>You can check installed version of petisco with:</p> <pre><code>$ petisco --version\npetisco \ud83c\udf6a =&gt; 2.X.X\n</code></pre> <p>Or generate a random UUID v4 with:</p> <pre><code>$ petisco --uuid\na4161d89-9819-4730-99e3-7d2890fb17bc\n</code></pre> <p>And also print the current <code>utcnow</code>:</p> <pre><code>$ petisco --utcnow\n2023-05-22 13:49:13.243518\n</code></pre>"},{"location":"cli/#petisco-dev","title":"<code>petisco-dev</code>","text":"<p>Provides various commands to help you interact with and manage your petisco-based application.</p> <p>This is what <code>petisco-dev</code> provides us:</p> <pre><code>$ petisco-dev --help\npetisco dev tools to inspect your application\n\noptions:\n  -h, --help            show this help message and exit\n  -i, --info            show petisco app info.\n  -deps, --dependencies\n                        show petisco app dependencies.\n  -configs, --configurers\n                        show petisco app configurers.\n  -sql-models, --sql-models\n                        show petisco sql models.\n  -declarative-base DECLARATIVE_BASE, --declarative-base DECLARATIVE_BASE\n                        path to DeclarativeBase, a class to gather all the SQL models\n  --application APPLICATION\n                        Module path (default app.application)\n</code></pre> <p>Info</p> <p>If <code>rich</code> package is installed, information will use it to show valuable information in a fancy way.</p>"},{"location":"cli/#show-info","title":"Show info","text":"<pre><code>$ petisco-dev --info\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Petisco Application \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 name:          my-petisco-app            \u2502\n\u2502 version:       1.0.1                     \u2502\n\u2502 organization:  alice                     \u2502\n\u2502 deployed_at:   2023-05-16 10:41:39       \u2502\n\u2502 dependencies:  1                         \u2502\n\u2502 configurers:   2                         \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"cli/#show-dependencies","title":"Show dependencies","text":"<pre><code>$ petisco-dev --dependencies\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503      Type\u2503Default      \u2503Implementation      \u2503ENV            \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502Repository\u2502SqlRepository\u2502fake: FakeRepository\u2502REPOSITORY_TYPE\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"cli/#show-configurers","title":"Show configurers","text":"<pre><code>$ petisco-dev --configurers\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503                Configurer \u2503 execute_after_dependencies \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502     PersistenceConfigurer \u2502           False            \u2502\n\u2502 RabbitMqMessageConfigurer \u2502            True            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Help</p> <p>This information is obtained from instantiating a <code>petisco.Application</code>.</p> <p>By default, <code>petisco-dev</code> searches this application in the module <code>app.application</code>:</p> app/application.py<pre><code>from petisco.extra.fastapi import FastApiApplication\n\nfrom app import (\n    APPLICATION_LATEST_DEPLOY,\n    APPLICATION_NAME,\n    APPLICATION_VERSION,\n    ORGANIZATION,\n)\nfrom app.fastapi import fastapi_configurer\nfrom app.petisco.configurers.configurers import configurers\nfrom app.petisco.dependencies.dependencies_provider import dependencies_provider\n\napplication = FastApiApplication(\n    name=APPLICATION_NAME,\n    version=APPLICATION_VERSION,\n    organization=ORGANIZATION,\n    deployed_at=APPLICATION_LATEST_DEPLOY,\n    dependencies_provider=dependencies_provider,\n    configurers=configurers,\n    fastapi_configurer=fastapi_configurer,\n)\n</code></pre> <p>If your application is defined in other file, you can modify it with <code>petisco-dev --info --application app.other.module.application</code>. </p>"},{"location":"cli/#show-sql-models","title":"Show SQL Models","text":"<p>To show SQL models inheriting from <code>petisco.extra.sqlalchemy.SqlBase</code> use the following command:</p> <pre><code>$ petisco-dev --sql-models\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503       Model \u2503 Filename                                     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502     SqlUser \u2502 app/src/infrastructure/models/sql_user.py    \u2502\n\u2502   SqlClient \u2502 app/src/infrastructure/models/sql_client.py  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>If you want to specify your own implementation of your <code>DeclarativeBase</code> just pass the path to your extension</p> <pre><code>$ petisco-dev --sql-models --declarative-base app.models.extended_declarative_base.ExtendedDeclarativeBase\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503         Model \u2503 Filename                                     \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502     OtherUser \u2502 app/models/other_user.py                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"configuration/","title":"Configuration","text":""},{"location":"configuration/#middleware","title":"Middleware","text":"Envvar Default Options Description <code>PETISCO_DEFAULT_MIDDLEWARES</code> NotifierMiddleware,PrintMiddleware Registered implementation Define default"},{"location":"configuration/#dependencies","title":"Dependencies","text":"Install Default Options Description <code>PETISCO_NOTIFIER_TYPE</code> slack not_implemented Set the notifier implementation <code>PETISCO_DOMAIN_EVENT_BUS_TYPE</code> rabbitmq not_implemented Set the DomainEventBus implementation <code>PETISCO_COMMAND_BUS_TYPE</code> rabbitmq not_implemented Set the CommandBus implementation <code>PETISCO_MESSAGE_CONFIGURER_TYPE</code> rabbitmq not_implemented Set the implementation of the message broker configuration <code>PETISCO_MESSAGE_CONSUMER_TYPE</code> rabbitmq not_implemented Set the implementation of the message broker consumer (add subscribers)"},{"location":"configuration/#rabbitmq","title":"RabbitMQ","text":"Install Default Options Description <code>PETISCO_RABBITMQ_CONFIGURER_CLEAR_SUBSCRIBER_BEFORE</code> false bool <code>PETISCO_RABBITMQ_CONFIGURER_CLEAR_STORE_BEFORE</code> false bool <code>PETISCO_RABBITMQ_MAX_ATTEMPTS_TO_RECONNECT_CONSUMER</code> 20 int Set max number of attempt to try to reconnect rabbitmq channel in the consumer <code>PETISCO_RABBITMQ_WAIT_SECONDS_TO_RECONNECT_CONSUMER</code> 5 int Set wait time (in seconds) to retry to reconnect rabbitmq channel in the consumer"},{"location":"contributing/","title":"Contributing to petisco","text":"<p>We'd love you to contribute to petisco \ud83e\udd73\ud83e\udd73\ud83e\udd73\ud83e\udd73\ud83e\udd73\ud83e\udd73\ufe0f!</p> <ul> <li>Questions, feature requests and bug reports are all welcome as discussions or issues. </li> <li>However, to report a security vulnerability, please see our security policy.</li> </ul>"},{"location":"databases/","title":"Databases","text":"<p>Petisco provides a high-level, intuitive, and Pythonic interface to interact with databases. It abstracts away the  complexities of working with different database systems, allowing developers to focus on their application logic rather  than the intricacies of various SQL dialects or low-level database operations. With this framework, you can work with  popular databases like MySQL, PostgreSQL, SQLite, Elastic, and many more, without having to learn the specifics of each  system.</p>"},{"location":"databases/#configuration","title":"Configuration","text":"<p>We recommend to configure (and initialize) databases using an <code>ApplicationConfigurer</code>. Check the following example of a <code>FastApiApplication</code>. </p> app/application.py<pre><code>from petisco.extra.fastapi import FastApiApplication\n\nfrom app import (\n    APPLICATION_LATEST_DEPLOY,\n    APPLICATION_NAME,\n    APPLICATION_VERSION,\n    ORGANIZATION,\n)\nfrom app.fastapi import fastapi_configurer\nfrom app.petisco.dependencies.dependencies_provider import dependencies_provider\nfrom app.petisco.configurers import DatabasesConfigurer\n\nconfigurers = [DatabasesConfigurer()]\n\napplication = FastApiApplication(\n    name=APPLICATION_NAME,\n    version=APPLICATION_VERSION,\n    organization=ORGANIZATION,\n    deployed_at=APPLICATION_LATEST_DEPLOY,\n    dependencies_provider=dependencies_provider,\n    configurers=configurers,\n    fastapi_configurer=fastapi_configurer,\n)\n</code></pre> <p>In the <code>DatabasesConfigurer</code> we have to initialize databases, using the global <code>databases</code> object adding each  implementation of <code>Database</code> abstract class. The following example configures a <code>SqlDatabase</code> connecting with a MySQL or a SQLite backend depending on some configuration.</p> <pre><code>import os\n\nfrom petisco import ApplicationConfigurer, databases\nfrom petisco.extra.sqlalchemy import MySqlConnection, SqlDatabase, SqliteConnection\n\nDATABASE_NAME = \"petisco-sql\"\nROOT_PATH = os.path.abspath(os.path.dirname(__file__))\nSQL_SERVER = os.getenv(\"SQL_SERVER\", \"sqlite\")\n\nclass DatabasesConfigurer(ApplicationConfigurer):\n    def execute(self, testing: bool = True) -&gt; None:\n        if testing or (SQL_SERVER == \"sqlite\"):\n          test_db_filename = \"onboarding-test.db\"\n          connection = SqliteConnection.create(\"sqlite\", test_db_filename) \n        else:\n          connection = MySqlConnection.from_environ() \n\n        sql_database = SqlDatabase(name=DATABASE_NAME, connection=connection) \n\n        databases.add(sql_database) # (1)\n        databases.initialize() # (2)\n</code></pre> <ol> <li>Adds the <code>SqlDatabase</code> implementation to the global <code>databases</code> object</li> <li>Initializes all the added implementations.</li> </ol> <p>Use available implementations</p> <p>Add other available implementation as <code>ElasticDatabase</code> easily with:</p> <pre><code>  from petisco import databases\n  from petisco.extra.elastic import ElasticDatabase, ElasticConnection\n\n  ...\n\n  sql_database = SqlDatabase(name=DATABASE_NAME, connection=connection) \n  elastic_database = ElasticDatabase(connection=ElasticConnection.create_local())\n\n  databases.add(sql_database)\n  databases.add(elastic_database)\n  databases.initialize()\n</code></pre> <p>Extend Database</p> <p>You can extend the <code>Database</code> abstract class and create your own implementation</p> <pre><code>from typing import Callable, ContextManager\nfrom petisco import Database\n\nclass YourExtensionDatabase(Database):\n\n    def initialize(self) -&gt; None:\n        # Add your stuff\n        pass\n\n    def delete(self):\n        # Add your stuff\n        pass\n\n    def clear_data(self, base: DeclarativeBase = SqlBase) -&gt; None:\n        # Add your stuff\n        pass\n\n    def get_session_scope(self) -&gt; Callable[..., ContextManager[T]]:\n        # Add your stuff\n        pass\n\n    def is_available(self):\n        # Add your stuff\n        pass\n</code></pre>"},{"location":"databases/#usage","title":"Usage","text":"<p>Once databases are initialized (after <code>databases.initializes()</code>), we should be ready to use these implementations.  Let's overview how to use it through a repository implementation. Note that uses <code>databases</code> instance to retrieve the  <code>get_session_scope</code> for the specified database name.</p> <pre><code>from meiga import BoolResult, early_return, isSuccess\nfrom petisco import databases, Repository\nfrom app.src.models import SqlUser, User\n\n\nclass SqlUserRepository(Repository):\n    session_scope: SqlSessionScope\n\n    def __init__(self):\n        # `DATABASE_NAME = \"petisco-sql\"` -&gt; same as defined in the configuration \n        database = databases.get(SqlDatabase, alias=DATABASE_NAME)\n        self.session_scope = database.get_session_scope()\n\n    @early_return\n    def save(self, user: User) -&gt; BoolResult:\n        with self.session_scope() as session:\n            sql_user = SqlUser.from_domain(user)\n            session.add(sql_user)\n        return isSuccess\n    ...\n</code></pre> <p>If you inherit from <code>SqlRepository</code> or <code>ElasticRepository</code> you don't need to define the session scope and the  <code>__init__</code> constructor:</p> <pre><code>from meiga import BoolResult, early_return, isSuccess\nfrom petisco.extra.sqlalchemy import SqlRepository\nfrom app.src.models import SqlUser, User\n\n\nclass SqlUserRepository(SqlRepository):\n\n    @early_return\n    def save(self, user: User) -&gt; BoolResult:\n        with self.session_scope() as session:\n            sql_user = SqlUser.from_domain(user)\n            session.add(sql_user)\n        return isSuccess\n    ...\n\n\n# `DATABASE_NAME = \"petisco-sql\"` -&gt; same as defined in the configuration \nsql_user_repository = SqlUserRepository(database_alias=DATABASE_NAME)\n</code></pre> <p>Note</p> <p>For more details about how to use specific <code>Database</code> implementations, check the documentation in:</p> <ul> <li>SQLAlchemy</li> <li>Elastic</li> </ul> <p>Note both extra modules implements aync version since petisco v2!</p>"},{"location":"domain/","title":"Domain","text":"<p><code>petisco \ud83c\udf6a</code> is a framework which helps you to model you domain. </p> <pre><code>flowchart TD\n\n        subgraph Domain\n\n        subgraph Entities\n        aggregateroot([Aggregate Root])\n        uuid((Uuid))\n        valueobject([Value Object])\n        aggregateroot -.-&gt; valueobject\n        uuid --&gt; valueobject\n        end\n\n        notifier([Notifier])\n        appservice([AppService])\n        repository([Repository])\n        domainerror([Domain Error])   \n\n        subgraph Message\n        domainevent([Domain Event])\n        command([Command])\n        basemessage([Message])\n        domainevent --&gt; basemessage\n        command --&gt; basemessage\n        end\n\n\n\n\n        end\n\n        style Domain fill:#D6EAF8</code></pre> <p>Continuing with the Task Manager example (see Getting Started), let's see some examples of domain entities and models that can help you.</p>"},{"location":"domain/#entities","title":"Entities","text":""},{"location":"domain/#uuid","title":"UUID","text":"<p>Use <code>Uuid</code> to generate new identifiers.</p> <pre><code>from petisco import Uuid\nuuid = Uuid.v4()\n</code></pre> <p>Additionally, you can extend it:</p> <pre><code>from petisco import Uuid\n\nclass TaskId(Uuid): ...\n\ntask_id = TaskId.v4()\n</code></pre> <p>Help</p> <p>Use this class to interoperate with <code>uuid.UUID</code> and <code>pydantid.UUID4</code>. Those are very useful to document OpenAPI documentation.</p> <pre><code>from uuid import uuid4\n\nfrom pydantic import BaseModel, UUID4, Field\n\nfrom petisco import AggregateRoot, Uuid\n\n\nclass TaskIn(BaseModel):\n    id: UUID4 = Field(default_factory=uuid4)\n    name: str\n\n\nclass Task(AggregateRoot):\n    name: str\n\n    @staticmethod\n    def from_task_in(task_in: TaskIn) -&gt; \"Task\":\n        return Task(\n            aggregate_id=Uuid.from_uuid(task_in.id),\n            name=task_in.name\n        )\n</code></pre>"},{"location":"domain/#value-objects","title":"Value Objects","text":"<p>Create your Value Objects extending from <code>ValueObject</code> base class.</p> <pre><code>from pydantic import field_validator\nfrom meiga import Failure\nfrom petisco import ValueObject, DomainError\n\nclass EmptyValueObjectError(DomainError): ...\nclass ExceedLengthLimitValueObjectError(DomainError): ...\n\ndef ensure_not_empty_value(value, classname: str = None):\n    if value is None:\n        raise Failure(EmptyValueObjectError(classname))\n\n\ndef ensure_value_is_less_than_200_char(value):\n    if len(value) &gt; 200:\n        raise ExceedLengthLimitValueObjectError(value)\n\n\nclass Description(ValueObject):\n\n    @field_validator('value')\n    def validate_value(cls, value):\n        ensure_not_empty_value(value, cls.__name__)\n        ensure_value_is_less_than_200_char(value)\n        return value.title()\n</code></pre> <p>Note</p> <p>Sometimes we want to keep only the wrapped value when serializing. In other words, we don't want to keep <code>{\"value\":  \"my-value\"}</code>. To do this, you can use Annotated write with:</p> <pre><code>from typing import Annotated\nfrom pydantic import BaseModel\nfrom petisco import ValueObjectSerializer\n\nclass MyModel(BaseModel):\n  model_id: Annotated[Uuid, ValueObjectSerializer] # (1)\n</code></pre> <ol> <li><code>ValueObjectSerializer</code> is equivalent to <code>PlainSerializer(lambda value_object: value_object.value if value_object else None)</code></li> </ol> <p>Otherwise, you can also use <code>field_serializer</code> to solve this with:</p> <pre><code>from pydantic import BaseModel\nfrom petisco import Uuid, ValueObject\n\n\nclass MyModel(BaseModel):\n  model_id: Uuid\n\n  _model_id = ValueObject.serializer(\"model_id\")  # (1)\n</code></pre> <ol> <li>This is equivalent to <code>_model_id = field_serializer(\"model_id\")(lamdba value_object: value_object.value)</code></li> </ol>"},{"location":"domain/#aggregate-root","title":"Aggregate Root","text":"<p>Quote</p> <p>As Evans define:</p> <p>\"An AGGREGATE is a cluster of associated objects that we treat as a unit for the purpose of data changes.  Each AGGREGATE has a root and a boundary. The boundary defines what is inside the AGGREGATE.  The root is a single, specific ENTITY contained in the AGGREGATE.\"</p> <p>...</p> <p>\"The root is the only member of the AGGREGATE that outside objects are allowed to hold references to[.]\"</p> <p>To define your data model, just extend from <code>AggregateRoot</code> to obtain useful features.</p> <pre><code>from petisco import AggregateRoot\nfrom datetime import datetime\n\nfrom my_app import Description, TaskCreated, TaskId, Title\n\nclass Task(AggregateRoot):\n    title: Title  # &lt;== ValueObject\n    description: Description # &lt;== ValueObject\n    created_at: datetime\n\n    @staticmethod\n    def create(task_id: TaskId, title: Title, description: Description):\n        task = Task(aggregate_id=task_id, title=title, description=description, created_at=datetime.utcnow())\n        task.record(TaskCreated(task_id=task_id))\n        return task\n</code></pre> <p>Define a name constructor as the static method <code>create</code> to simplify the construction and the record of the domain events related with the Task <code>AggregateRoot</code>.</p> <p>Then, you can get all the event with <code>pull_domain_events</code>.</p> <pre><code>task = Task.create(\n    task_id=TaskId.v4(),\n    title=\"petisco\",\n    description=\"Learning petisco is nice!\"\n)\ndomain_events = task.pull_domain_events() # This will return a list of DomainEvents ([TaskCreated(task_id=task_id)])\n</code></pre>"},{"location":"domain/#messaging","title":"Messaging","text":"<pre><code>flowchart TD\n        domainevent([Domain Event])\n        command([Command])\n        basemessage([Message])\n        domainevent --&gt; basemessage\n        command --&gt; basemessage</code></pre>"},{"location":"domain/#domain-event","title":"Domain Event","text":"<p>Use <code>DomainEvent</code> to model the actions of our domain that are of interest to our business logic.</p> <pre><code>from petisco import DomainEvent, Uuid\n\nclass TaskId(Uuid): ...\n\nclass TaskCreated(DomainEvent):\n    task_id: TaskId\n\nclass TaskRemoved(DomainEvent):\n    task_id: TaskId\n\nclass TaskRetrieved(DomainEvent):\n    task_id: TaskId\n</code></pre> <p><code>DomainEvent</code> inherits from <code>Message</code> that have available <code>dict</code> and <code>json</code> method to encode the info.</p> <pre><code>my_domain_event = TaskCreated(task_id=TaskId.v4())\n\nprint(my_domain_event.json())\n</code></pre> <p>The result should be something like the following: <pre><code>{\n    \"data\": {\n        \"id\": \"3a4d78aa-6870-41cb-aa14-964831511d86\",\n        \"type\": \"task.created\",\n        \"type_message\": \"domain_event\",\n        \"version\": 1,\n        \"occurred_on\": \"2021-12-28 14:11:47.845618\",\n        \"attributes\": {\"task_id\": \"a7f8b62a-c9e5-4f3c-a451-47cd1965958f\"},\n        \"meta\": {},\n    }\n}\n</code></pre></p> <p><code>attributes</code> is a representation of the class:</p> <pre><code>class TaskCreated(DomainEvent):\n    task_id: TaskId\n</code></pre> <p>You can also add metadata to your domain event payload</p> <pre><code>domain_event =  TaskCreated(task_id=TaskId.v4()).add_meta({\"correlation_id\": \"d8ed76aa-2fce-48f2-9470-ec5048783fe1\"})\n</code></pre> <p>The result is:</p> <pre><code>{\n    \"data\": {\n        \"id\": \"3a4d78aa-6870-41cb-aa14-964831511d86\",\n        \"type\": \"task.created\",\n        \"type_message\": \"domain_event\",\n        \"version\": 1,\n        \"occurred_on\": \"2021-12-28 14:11:47.845618\",\n        \"attributes\": {\"task_id\": \"a7f8b62a-c9e5-4f3c-a451-47cd1965958f\"},\n        \"meta\": {\"correlation_id\": \"d8ed76aa-2fce-48f2-9470-ec5048783fe1\"} # &lt;== Added meta info\n    }\n}\n</code></pre> <p>Tip</p> <p>If you want to modify the version of the Message, use the inner class <code>Config</code>:</p> <pre><code>class TaskCreated(DomainEvent):\n    task_id: TaskId\n\n    class Config:\n        version = 2\n</code></pre> <p>Default value of message version is 1.</p> <p>Warning</p> <p>\ud83d\udeabDO NOT overwrite the constructor of the Message \ud83d\udeab. This could cause errors on the serialization of the message. If you want to do an acction before the construction, use a named constructor as follows:</p> <pre><code>class TaskCreated(DomainEvent):\n    complete_name: str\n    first_name: str | None = None\n\n    @staticmethod\n    def create(complete_name: str) -&gt; \"TaskCreated\":\n        return TaskCreated(\n            complete_name=complete_name,\n            first_name=complete_name.split(\" \")[0]\n        )\n</code></pre>"},{"location":"domain/#command","title":"Command","text":"<p>If you use CQRS you can use also the <code>Command</code> class. Extend from it when you want to model an imperative action to be done.</p> <pre><code>from petisco import Command, Uuid\n\nclass TaskId(Uuid): ...\n\nclass UpdateTask(Command):\n    task_id: TaskId\n\nmy_command = UpdateTask(task_id=TaskId.v4())\n\nprint(my_command.json())\n</code></pre> <p>The result:</p> <pre><code>{\n    \"data\": {\n        \"id\": \"1f35e414-0636-4983-987e-13d522749709\",\n        \"type\": \"update.task\",\n        \"type_message\": \"command\",\n        \"version\": 1,\n        \"occurred_on\": \"2021-12-28 14:19:09.149651\",\n        \"attributes\": {\"task_id\": \"db0970be-f6b6-478b-976a-f83e85112b90\"},\n        \"meta\": {},\n    }\n}\n</code></pre>"},{"location":"domain/#domaineventbus","title":"DomainEventBus","text":"<p>Use <code>DomainEventBus</code> to publish <code>DomainEvent</code>s in your Use Cases. </p> Example of usage into a <code>UseCase</code> <pre><code>from meiga import BoolResult, isSuccess\nfrom petisco import CrudRepository, DomainEventBus, UseCase\n\nfrom app.src.task.label.domain.task_labeler import TaskLabeler\nfrom app.src.task.shared.domain.task import Task\n\n\nclass TaskCreator(UseCase):\n    def __init__(\n        self,\n        labeler: TaskLabeler,\n        repository: CrudRepository,\n        domain_event_bus: DomainEventBus,\n    ):\n        self.labeler = labeler\n        self.repository = repository\n        self.domain_event_bus = domain_event_bus\n\n    def execute(self, task: Task) -&gt; BoolResult:\n        task = self.labeler.execute(task).unwrap_or_return()\n        self.repository.save(task).unwrap_or_return()\n        domain_events = task.pull_domain_events() # (1)\n        self.domain_event_bus.publish(domain_events) # (2)\n        return isSuccess\n</code></pre> <ol> <li>Pull <code>DomainEvent</code>s from the <code>Task</code> Aggregate.</li> <li>Publish retrieved <code>DomainEvent</code>s. </li> </ol>"},{"location":"domain/#commandbus","title":"CommandBus","text":"<p>Use <code>CommandBus</code> to dispatch <code>Command</code>s in your Use Cases or Controllers.</p>"},{"location":"domain/#other-domain-elements","title":"Other Domain Elements","text":""},{"location":"domain/#domain-error","title":"Domain Error","text":"<p>Model your domain errors extending from <code>DomainError</code>:</p> <pre><code>from petisco import DomainError\n\nclass TaskAlreadyExistError(DomainError): ...\nclass TaskNotFoundError(DomainError): ...\n</code></pre> <p>You can add additional information to <code>DomainError</code> objects using <code>additional_info</code> argument:</p> <pre><code>domain_error = TaskNotFoundError(additional_info={\"error\": \"detail\"})\n</code></pre> <p>or also you can add related uuid with </p> <pre><code>domain_error = TaskNotFoundError(uuid_value=task_id.value, additional_info={\"error\": \"detail\"})\n</code></pre> <p>Note</p> <p><code>petisco</code> provides some default errors such as <code>UnknownError</code> and <code>CriticalError</code>.</p> <p>Additionally, the framework defines <code>DEFAULT_HTTP_ERROR_MAP</code> with some default errors and its correspondences with <code>HttpErrors</code>.</p> <pre><code>DEFAULT_HTTP_ERROR_MAP = {\n    DomainError: HttpError(status_code=500),\n    NotFound: HttpError(status_code=404),\n    AlreadyExists: HttpError(status_code=409),\n    AggregateNotFoundError: HttpError(status_code=404),\n    AggregatesNotFoundError: HttpError(status_code=404),\n    AggregateAlreadyExistError: HttpError(status_code=409),\n    ClientNotFound: HttpError(status_code=404),\n    ClientAlreadyExists: HttpError(status_code=409),\n    UserNotFound: HttpError(status_code=404),\n    UserAlreadyExists: HttpError(status_code=409),\n    InvalidUuid: HttpError(status_code=422),\n    InvalidValueObject: HttpError(status_code=500),\n}\n</code></pre>"},{"location":"domain/#notifier","title":"Notifier","text":"<p>Implement your notifier inheriting from <code>Notifier</code>.</p> <pre><code>from petisco import Notifier, NotifierMessage, NotifierExceptionMessage\n\nclass MyDummyNotifier(Notifier):\n\n    def publish(self, notifier_message: NotifierMessage):\n        print(f\"Publishing {notifier_message}\")\n\n      def publish_exception(self, notifier_exception_message: NotifierExceptionMessage):\n            print(f\"Publishing exeception {notifier_exception_message}\")\n</code></pre>"},{"location":"domain/#appservices","title":"AppServices","text":"<p>Implement your app services inheriting from <code>AppService</code>.</p> <pre><code>from petisco import AppService\n\nclass MyDummyAppService(AppService):\n\n    def execute(self, input_param: str):\n        # Add your code here\n</code></pre>"},{"location":"domain/#repositories","title":"Repositories","text":"<p>Implement your repositories inheriting from <code>Repository</code>. This interface do not expose any abstract method, so you can  extend it as you want.</p> <pre><code>from petisco import Repository\nfrom my_app import TaskId\n\nclass MyDummyRepository(Repository):\n\n    def retrieve(self, task_id: TaskId):\n        task = task_from_task_id(task_id)\n        return task\n</code></pre> Example with CRUD Repository <p>Otherwise, if you want to model a repository for a CRUD application, you can inherit from <code>CrudRepository</code></p> <pre><code>from typing import Any, Dict, List\n\nfrom meiga import BoolResult, Error, Failure, Result, Success, isSuccess, early_return\n\nfrom petisco.base.application.patterns.crud_repository import (\n    AggregateRootType,\n    CrudRepository,\n)\nfrom petisco.base.domain.errors.defaults.already_exists import (\n    AggregateAlreadyExistError,\n)\nfrom petisco.base.domain.errors.defaults.not_found import AggregateNotFoundError\nfrom petisco.base.domain.model.uuid import Uuid\n\n\nclass InmemoryCrudRepository(CrudRepository[AggregateRootType]):\n    def __init__(self):\n        self._data: Dict[Uuid, Any] = dict()\n\n    @early_return\n    def save(self, aggregate_root: AggregateRootType) -&gt; BoolResult:\n        if aggregate_root.aggregate_id in self._data:\n            return Failure(AggregateAlreadyExistError(aggregate_root.aggregate_id))\n        self._data[aggregate_root.aggregate_id] = aggregate_root\n        return isSuccess\n\n    @early_return\n    def retrieve(self, aggregate_id: Uuid) -&gt; Result[AggregateRootType, Error]:\n        aggregate_root = self._data.get(aggregate_id)\n        if aggregate_root is None:\n            return Failure(AggregateNotFoundError(aggregate_id))\n        return Success(aggregate_root)\n\n    def update(self, aggregate_root: AggregateRootType) -&gt; BoolResult:\n        if aggregate_root.aggregate_id not in self._data:\n            return Failure(AggregateNotFoundError(aggregate_root.aggregate_id))\n        self._data[aggregate_root.aggregate_id] = aggregate_root\n        return isSuccess\n\n    def remove(self, aggregate_id: Uuid) -&gt; BoolResult:\n        if aggregate_id not in self._data:\n            return Failure(AggregateNotFoundError(aggregate_id))\n        self._data.pop(aggregate_id)\n        return isSuccess\n\n    def retrieve_all(self) -&gt; Result[List[AggregateRootType], Error]:\n        return Success(list(self._data.values()))\n</code></pre>"},{"location":"getting_started/","title":"Getting started","text":"<p>This package helps on the creation of web applications. <code>petisco</code> provides several classes to help model the domain and  manage the lifecycle of applications with a hexagonal architecture. In addition, it provides abstractions to extend with your infrastructure details.</p> <p>Versions</p> <p>First version of <code>petisco</code> (v0) born quite coupled to Flask web framework. Now, <code>petisco</code> v1 is not coupled to any web framework. Nevertheless, the package provides some examples and useful tool to  speed up the integration with the awesome FastAPI framework.</p>"},{"location":"getting_started/#application","title":"Application","text":"<p>The <code>Application</code> class defines the starting point of your web application. This class allows you to configure your  application, and prepare it to start responding to requests.</p> <p>The following code is the minimum to define and configure an application:</p> <pre><code>from petisco import Application\nfrom datetime import datetime\n\napplication = Application(\n    name=\"my-app\",\n    version=\"1.0.0\",\n    organization=\"acme\",\n    deployed_at=str(datetime.utcnow()),\n    environment=\"staging\",\n)\napplication.configure()\n</code></pre> <p>Since no dependencies or configurators have been added, running <code>configure</code> will have no side effects.</p>"},{"location":"getting_started/#define-your-dependencies","title":"Define your Dependencies \ud83c\udfaf","text":"<pre><code>flowchart LR\n        subgraph Application\n        configure([Configure])\n        end\n\n        configure -- Set Dependencies --&gt; Container\n\n        style configure fill:#D6EAF8</code></pre> <p>You can define your dependencies adding a callable (dependencies_provider - <code>Optional[Callable[..., List[Dependency]]]</code>).</p> <pre><code>from petisco import (\n    Application,\n    Dependency,\n    Builder,\n    InmemoryCrudRepository,\n    AggregateRoot,\n)\nfrom datetime import datetime\n\nclass Task(AggregateRoot): ...\n\n# Class to define your dependencies \ud83c\udfaf\ndef dependencies_provider() -&gt; list[Dependency]:\n    dependencies = [\n        Dependency( \n            TaskRepository,\n            builders={\"default\": Builder(InmemoryCrudRepository[Task])}\n        )\n    ]\n    return dependencies\n\n\napplication = Application(\n    name=\"my-app\",\n    version=\"1.0.0\",\n    organization=\"acme\",\n    deployed_at=str(datetime.utcnow()),\n    environment=\"staging\",\n    dependencies_provider=dependencies_provider,  # &lt;==== Adding dependencies \u2795\n)\napplication.configure()\n</code></pre> <p>When call <code>configure</code> method, dependencies will be checked and added to the <code>Container</code> of dependencies being ready to be consumed to inject them to the use cases.</p> Tip <p>Different implementations can be specified for each <code>Dependency</code>, depending on environment variables.</p> <pre><code>from petisco import (\n    Dependency,\n    Builder,\n    InmemoryCrudRepository,\n    AggregateRoot\n)\nfrom my_app import FolderTaskCrudRepository, MySQLTaskCrudRepository, ElasticTaskCrudRepository\n\nclass Task(AggregateRoot): ...\n\ndef dependencies_provider() -&gt; list[Dependency]:\n    dependencies = [\n        Dependency(\n            TaskRepository\n            builders={\n                \"default\": Builder(InmemoryCrudRepository[Task]), # (1) \n                \"folder\": Builder(\n                    FolderTaskCrudRepository, folder=\"folder_task_database\" # Here we have to add required parameter on the implementation constructor\n                ),\n                \"mysql\": Builder(\n                    MySQLTaskCrudRepository, connection=\"whatever required\" # Here we have to add required parameter on the implementation constructor\n                ),\n                \"elastic\": Builder(\n                    ElasticTaskCrudRepository, connection=\"whatever required\" # Here we have to add required parameter on the implementation constructor\n                )\n            },\n            envar_modifier=\"TASK_REPOSITORY_TYPE\", # (2)\n        )\n    ]\n    return dependencies\n</code></pre> <ol> <li>This \"default\" builder is mandatory.</li> <li><code>envar_modifier</code> value works as a selector of builders. </li> </ol> <p>When envar <code>TASK_REPOSITORY_TYPE</code> is not defined, default implementation is <code>InmemoryCrudRepository</code>. When <code>TASK_REPOSITORY_TYPE</code> has a valid value (available as a key in the <code>builders</code> dictation) the implementation  will be changed. These are the options configured in the <code>builders</code> dictionary :</p> <ul> <li><code>FolderTaskCrudRepository</code></li> <li><code>MySQLTaskCrudRepository</code></li> <li><code>ElasticTaskCrudRepository</code></li> </ul>"},{"location":"getting_started/#add-application-configurers","title":"Add Application Configurers \ud83d\udee0\ufe0f","text":"<pre><code>flowchart LR\n        subgraph Application\n        configure([Configure])\n        end\n\n        appconfig1([Application Configurer 1])\n        appconfig2([Application Configurer 2])\n        appconfign([Application Configurer N])\n\n        configure -- Run --&gt; appconfig1\n        configure -- Run --&gt; appconfig2\n        configure -- Run --&gt; appconfign\n\n        style configure fill:#D6EAF8</code></pre> <p>Extend from <code>ApplicationConfigurer</code> to model some logics you want to be executed at application startup. For example,  use it to initialize some repository, to configure your persistence, subscribers, etc.</p> Example <pre><code>from petisco import (\n    Application,\n    ApplicationConfigurer,\n    AggregateRoot,\n    Container\n)\nfrom datetime import datetime\n\nclass Task(AggregateRoot): \n    name: str\n    description: str\n\n# Configurer to add tasks to a specific repository (e.g. to init a tutorial)\nclass AddTasksForTutorialApplicationConfigurer(ApplicationConfigurer):\n    def __init__(self, tasks: list[Task]):\n        self.tasks = tasks\n        execute_after_dependencies = True\n        super().__init__(execute_after_dependencies)\n\n    def execute(self, testing: bool = False) -&gt; None:\n        repository = Container.get(TaskRepository)\n        for task in self.tasks:\n            repository.save(task)\n\nconfigurers = [\n    AddTasksForTutorialApplicationConfigurer(\n        tasks=[Task(name=\"petisco\", description=\"Learning petisco is nice!\")]\n    )\n]\n\napplication = Application(\n    name=\"my-app\",\n    version=\"1.0.0\",\n    organization=\"acme\",\n    deployed_at=str(datetime.utcnow()),\n    environment=\"staging\",\n    configurers=configurers,  # &lt;==== Adding your configurers \u2795\n)\napplication.configure()\n</code></pre> Use <code>testing</code> parameter <p>You can define diferent behaivor for testing environment using <code>testing</code> both in <code>ApplicationConfigurers</code> and <code>Application.configure</code> method.</p> <pre><code>import os\nfrom petisco import (\n    Application,\n    ApplicationConfigurer,\n    AggregateRoot,\n    Container\n)\nfrom datetime import datetime\n\nclass Task(AggregateRoot): \n    name: str\n    description: str\n\n# Configurer to perform an action only in testing\nclass OnlyTestingApplicationConfigurer(ApplicationConfigurer):\n    def __init__(self):\n        execute_after_dependencies = True\n        super().__init__(execute_after_dependencies)\n\n    def execute(self, testing: bool = False) -&gt; None:\n        if not testing:\n            return\n\n        notifier = Container.get(Notifier)\n        notifier.send_message(\"Message to Github Actions\")\n\nconfigurers = [\n    OnlyTestingApplicationConfigurer(\n        tasks=[Task(name=\"petisco\", description=\"Learning petisco is nice!\")]\n    )\n]\n\napplication = Application(\n    name=\"my-app\",\n    version=\"1.0.0\",\n    organization=\"acme\",\n    deployed_at=str(datetime.utcnow()),\n    environment=\"staging\",\n    configurers=configurers,  # &lt;==== Adding your configurers \u2795\n)\n\ntesting = strtobool(os.getenv(\"TESTING\", \"false\"))\napplication.configure(testing)\n</code></pre>"},{"location":"getting_started/#other-methods","title":"Other methods \ud83d\udc4c","text":"<p>The <code>Application</code> class also provides some useful methods as shown in the following table.</p> Method Definition <code>get_dependencies()</code> Return a list of set dependencies <code>clear()</code> Clear set dependencies <code>info()</code> Returns a json with information of the application and its configured dependencies <code>publish_domain_event(domain_event: DomainEvent)</code> Publish a domain event using configured <code>DomainEventBus</code> dependency <code>notify(message: NotifierMessage)</code> Notify a message using configured <code>Notifier</code> dependency <code>was_deploy_few_minutes_ago(minutes: int = 25)</code> Useful to decide some notification depending on when was the application deployed"},{"location":"getting_started/#fastapiapplication","title":"FastApiApplication \u26a1\ufe0f","text":"<p><code>FastApiApplication</code> inherits from <code>Application</code> adding some specifications to work with FastAPI web framework.  This specification is as simple as:</p> <pre><code>from typing import Callable\n\nfrom fastapi import FastAPI\n\nfrom petisco.base.application.application import Application\n\n\nclass FastApiApplication(Application):\n    fastapi_configurer: Callable[[], FastAPI]\n\n    def get_app(self) -&gt; FastAPI:\n        return self.fastapi_configurer()\n</code></pre> <p>Adding a callable to configure FastAPI object (<code>fastapi_configurer</code>).</p> <pre><code>from petisco.extra.fastapi import FastApiApplication\n\n...\n\napplication = FastApiApplication(\n    name=\"my-app\",\n    version=\"1.0.0\",\n    organization=\"acme\",\n    deployed_at=str(datetime.utcnow()),\n    dependencies_provider=dependencies_provider,\n    configurers=configurers,\n    fastapi_configurer=fastapi_configurer, # (1)\n)\n</code></pre> <ol> <li> <p>Function to initialize <code>FastAPI</code> object. </p> <p>Example:</p> <pre><code>from fastapi import FastAPI\n\n...\n\ndef fastapi_configurer() -&gt; FastAPI:\n    def configure_apm(app):\n        apm_config = {\n            \"SERVICE_NAME\": APPLICATION_NAME,\n            \"SERVER_URL\": os.environ.get(\"ELASTIC_APM_SERVER_HOST\"),\n            \"SECRET_TOKEN\": os.environ.get(\"ELASTIC_APM_SECRET_TOKEN\"),\n            \"ENVIRONMENT\": ENVIRONMENT,\n        }\n        apm = make_apm_client(apm_config)\n        app.add_middleware(ElasticAPM, client=apm)\n\n    docs_url = f\"{FASTAPI_PREFIX}/docs\"\n    app = FastAPI(\n        title=APPLICATION_NAME,\n        openapi_tags=OPENAPI_TAGS,\n        docs_url=docs_url,\n        openapi_url=f\"{FASTAPI_PREFIX}/openapi.json\",\n    )\n    app.include_router(checks.router, prefix=FASTAPI_PREFIX)\n    app.include_router(tasks.router, prefix=FASTAPI_PREFIX)\n\n    app.add_middleware(\n        CORSMiddleware, allow_origins=[\"*\"], allow_methods=[\"*\"], allow_headers=[\"*\"]\n    )\n    apm_enabled = ENVIRONMENT in [\"production\", \"staging\"]\n    if apm_enabled:\n        configure_apm(app)\n\n    return app\n</code></pre> </li> </ol> Tip <p>Check the architecture of a <code>petisco</code> + <code>FastAPI</code> web application in GitHub with the project petisco-fastapi-example.</p>"},{"location":"getting_started/#architecture","title":"Architecture","text":"<p>Once we have seen how the application is initialized, we can review which the architecture of <code>petisco</code> framework. The following diagram represent some entities into four layers:</p> <pre><code>flowchart LR\n\n        subgraph I/O\n        cli([CLI])\n        webapp([Web App])\n        message([Message Broker])\n        end\n\n        subgraph Application\n        dic([Container])        \n        dic-- Dependency Injection --&gt;usecase\n        controller([Controller])\n        usecase([UseCase])\n        subscriber([Subscriber])\n        controller --&gt; usecase\n        subscriber --&gt; usecase\n        end\n\n        webapp --&gt; controller\n        cli --&gt; controller\n        message --&gt; subscriber\n\n        subgraph Domain\n        petisco(((petisco)))\n        end\n\n        usecase --&gt; petisco\n\n        subgraph Infrastructure\n        Persistence[(Persistence)]\n        petisco --&gt; Persistence\n        petisco --&gt; Buses\n        petisco --&gt; Monitoring\n        petisco --&gt; Others\n        end     </code></pre> <ul> <li>I/O: Represents the entry point of your application. It could be the requests from the API, messages from a    message broker or commands from a CLI.</li> <li>Application: Objects to define and manage the busines logic of your application.</li> <li>Domain: Entities of your domain. This models defines tha application actors. As well as domain abstraction for    Application Services and Repositories.</li> <li>Infrastructure: Real implementation of domain abstraction to connect your application with external technology.    For example, integration with MySQL, RabbitMQ, Redis, etc.</li> </ul> <p>In the next sections we will start by reviewing the objects in charge of managing the application layer, then we will  review the domain layer, and finally we will review the extra infrastructure implementations that are available in the  package.</p>"},{"location":"install/","title":"Install","text":"<p>Installation is as simple as:</p> <pre><code>$ pip install petisco\n---&gt; 100%\nSuccessfully installed petisco\n</code></pre> <p>This will install the latest version of petisco package \u270c\ufe0f  </p>"},{"location":"install/#base-requirements","title":"Base Requirements","text":"<ul> <li>meiga: A Python \u00b5framework that provides a simple, fully typed, monad-based result type.</li> <li>pydantic: Data validation and settings management using Python type annotations.</li> <li>requests: An elegant and simple HTTP library for Python, built for human beings.</li> <li>pyjwt[crypto]: A Python library which allows you to encode and decode JSON Web Tokens (JWT). JWT is an open, industry-standard (RFC 7519) for representing claims securely between two parties.</li> <li>validators: Python Data Validation for Humans</li> <li>pyyaml: A full-featured YAML framework for the Python programming language.</li> <li>loguru: Loguru is a library which aims to bring enjoyable logging in Python.</li> </ul>"},{"location":"install/#extras","title":"Extras","text":"<p>To install extras:</p> <pre><code>$ pip install petisco[sqlalchemy, redis, rabbitmq, slack, elastic, elastic-apm, fastapi, rich]\n---&gt; 100%\nSuccessfully installed petisco\n</code></pre>"},{"location":"extra/elastic/elastic/","title":"Elastic","text":"<p>The <code>ElasticDatabase</code> is an specific implementation of a <code>Database</code> using the elastic python client. This object encapsulates some specific Elastic stuff and provides it as a scoped session.</p>"},{"location":"extra/elastic/elastic/#connections","title":"Connections","text":"<p>When you define a <code>ElasticDatabase</code> you have to specify the connection. Petisco already provides the <code>ElasticConnection</code> object.</p> <pre><code>from petisco.extra.elastic import ElasticConnection, ElasticDatabase\n\nconnection = ElasticConnection.create_local()\ndatabase = ElasticDatabase(name=\"elastic_test\", connection=connection)\n</code></pre>"},{"location":"extra/elastic/elastic/#session","title":"Session","text":"<p>The <code>ElasticDatabase</code> implements the <code>get_session_scope</code> method to get a context manager with a pre-configured  <code>ElasticSearch</code> client.</p> <pre><code>from petisco.extra.elastic import ElasticConnection, ElasticDatabase\n\nconnection = ElasticConnection.create_local()\ndatabase = ElasticDatabase(name=\"elastic_test\", connection=connection)\ndatabase.initialize()\n\nsession_scope = database.get_session_scope()\nwith session_scope() as es:\n    document = {\n        \"title\": \"Example Document\",\n        \"content\": \"This is the content of the document.\",\n    }\n    index_name = \"my-index\"\n    response = es.index(index=index_name, document=document)\n</code></pre>"},{"location":"extra/elastic/elastic/#async","title":"Async","text":"<p>Petisco also provides an async implementation, the <code>AsyncElasticDatabase</code>. To run it with async/await pattern, you could run the following:</p> <pre><code>from petisco.extra.elastic import ElasticConnection, AsyncElasticDatabase\n\nconnection = ElasticConnection.create_local()\ndatabase = AsyncElasticDatabase(name=\"elastic_test\", connection=connection)\ndatabase.initialize()\n\nsession_scope = database.get_session_scope()\n\nasync with session_scope() as es:\n    document = {\n        \"title\": \"Example Document\",\n        \"content\": \"This is the content of the document.\",\n    }\n    index_name = \"my-index\"\n    response = await es.index(index=index_name, document=document)\n    assert response.get(\"result\") == \"created\"\n</code></pre>"},{"location":"extra/fastapi/fastapi/","title":"FastAPI","text":"<pre><code>$ pip install petisco[fastapi]\n---&gt; 100%\nSuccessfully installed petisco\n</code></pre> <p>When you install <code>petisco</code> with <code>fastapi</code> you can use <code>FastAPIApplication</code> and <code>FastAPIController</code></p> <pre><code>flowchart LR\n        subgraph FastAPI \n        fastapi_app[[FastAPIApplication]]\n        fastapi_controller[[FastAPIController]]\n        end\n\n        Application  --&gt; fastapi_app\n        Controller  --&gt; fastapi_controller\n\n        style Application fill:#D6EAF8\n        style fastapi_app fill:#00c800\n        style fastapi_controller fill:#00c800</code></pre> <p>Note</p> <p>The following examples are extracted from the project petisco-fastapi-example.</p>"},{"location":"extra/fastapi/fastapi/#fastapiapplication","title":"FastAPIApplication","text":"<pre><code>import os\n\nfrom elasticapm.contrib.starlette import ElasticAPM, make_apm_client\nfrom fastapi import FastAPI\nfrom petisco.extra.fastapi import FastApiApplication\nfrom starlette.middleware.cors import CORSMiddleware\n\nfrom app import (\n    APPLICATION_LATEST_DEPLOY,\n    APPLICATION_NAME,\n    APPLICATION_VERSION,\n    ENVIRONMENT,\n    ORGANIZATION,\n)\nfrom app.api import checks, tasks\nfrom app.api.openapi import FASTAPI_PREFIX, OPENAPI_TAGS\nfrom app.petisco.dependencies import dependencies_provider\n\n\ndef fastapi_configurer() -&gt; FastAPI:\n    def configure_apm(app):\n        apm_config = {\n            \"SERVICE_NAME\": APPLICATION_NAME,\n            \"SERVER_URL\": os.environ.get(\"ELASTIC_APM_SERVER_HOST\"),\n            \"SECRET_TOKEN\": os.environ.get(\"ELASTIC_APM_SECRET_TOKEN\"),\n            \"ENVIRONMENT\": ENVIRONMENT,\n        }\n        apm = make_apm_client(apm_config)\n        app.add_middleware(ElasticAPM, client=apm)\n\n    docs_url = f\"{FASTAPI_PREFIX}/docs\"\n    app = FastAPI(\n        title=APPLICATION_NAME,\n        openapi_tags=OPENAPI_TAGS,\n        docs_url=docs_url,\n        openapi_url=f\"{FASTAPI_PREFIX}/openapi.json\",\n    )\n    app.include_router(checks.router, prefix=FASTAPI_PREFIX)\n    app.include_router(tasks.router, prefix=FASTAPI_PREFIX)\n\n    app.add_middleware(\n        CORSMiddleware, allow_origins=[\"*\"], allow_methods=[\"*\"], allow_headers=[\"*\"]\n    )\n    apm_enabled = ENVIRONMENT in [\"production\", \"staging\"]\n    if apm_enabled:\n        configure_apm(app)\n\n    return app\n\n\napplication = FastApiApplication(\n    name=APPLICATION_NAME,\n    version=APPLICATION_VERSION,\n    organization=ORGANIZATION,\n    deployed_at=APPLICATION_LATEST_DEPLOY,\n    dependencies_provider=dependencies_provider,\n    fastapi_configurer=fastapi_configurer,\n)\n</code></pre>"},{"location":"extra/fastapi/fastapi/#ensure-that-all-fastapi-entry-point-are-async","title":"Ensure that all FastAPI entry point are <code>async</code>","text":"<p>In some applications you want to ensure all FastAPI routers are defined as <code>async</code>. You can force this with the  parameter <code>ensure_async_routers</code>.</p> <pre><code>application = FastApiApplication(\n    name=APPLICATION_NAME,\n    version=APPLICATION_VERSION,\n    organization=ORGANIZATION,\n    deployed_at=APPLICATION_LATEST_DEPLOY,\n    dependencies_provider=dependencies_provider,\n    fastapi_configurer=fastapi_configurer,\n    ensure_async_routers=True\n)\n</code></pre>"},{"location":"extra/fastapi/fastapi/#add-a-mock-response-guided-by-headers","title":"Add a mock response guided by headers","text":"<p>The main idea here is to add a FastAPI dependency to all the defined routers in order to check specific header (By default <code>X-Status-Code-Mock-Response</code>). This dependency will check given value through request headers returning defined status code. </p> <p>To add this behaviour to all the router we can add <code>ResponseMocker</code> dependency to global <code>FastAPI</code> app definition. </p> <pre><code>from fastapi import Depends, FastAPI\nfrom petisco.extra.fastapi import ResponseMocker\n\napp = FastAPI(\n    title=APPLICATION_NAME,\n    openapi_tags=OPENAPI_TAGS,\n    docs_url=docs_url,\n    openapi_url=f\"{FASTAPI_PREFIX}/openapi.json\",\n    dependencies=[Depends(ResponseMocker())]\n)\n</code></pre> <p>The following example illustrates how to use it as a client:</p> <pre><code>expected_status_code = 200\nresponse = client.get(\"path\", headers={\"X-Status-Code-Mock-Response\": 200})\nassert response.status_code == expected_status_code\n</code></pre> <p>If you want to override default header, use <code>header_key</code> parameter (e.g <code>ResponseMocker(header_key=\"MY-HEADER\")</code>), and use it as follows:</p> <pre><code>expected_status_code = 200\nresponse = client.get(\"path\", headers={\"MY-HEADER\": 200})\nassert response.status_code == expected_status_code\n</code></pre>"},{"location":"extra/fastapi/fastapi/#fastapicontroller","title":"FastAPIController","text":"<pre><code>from meiga import Result, Error\nfrom petisco import Container\nfrom petisco.extra.fastapi import FastAPIController\n\nfrom app.src.task.create.application.task_retriever import TaskRetriever\nfrom app.src.task.shared.domain.task import Task\n\n\nclass GetTaskController(FastAPIController):\n    def execute(self, task_id: UUID) -&gt; Result[Task, Error]:\n        task_retriever = TaskRetriever(\n            repository=Container.get(TaskRepository),\n            domain_event_bus=Container.get(DomainEventBus),\n        )\n        return task_retriever.execute(task_id)\n</code></pre>"},{"location":"extra/fastapi/fastapi/#fastapi-example","title":"FastAPI Example","text":"<p>Continuing with example described above (<code>GetTaskController</code>), this is how a petisco controller should be integrated in a FastAPI application.</p> <pre><code>from fastapi import FastAPI\nfrom petisco.extra.fastapi import as_fastapi\n\napp = FastAPI()\n\n\n@app.get(\"/task\")\ndef get_task(task_id: UUID):\n    result = GetTaskController().execute(task_id)\n    return as_fastapi(result)\n</code></pre> <p>We can also use some covinent tools given by FastAPI and petisco to better document and write your application giving a  better experience to your users and developers. </p> <pre><code>from fastapi import FastAPI\nfrom petisco.extra.fastapi import as_fastapi\n\napp = FastAPI()\n\n\n@app.get(\n    \"/task\",\n    summary=\"Return a task from a given task_id\",\n    description=\"Return a task from a given task_id. If not exist it will return an error.\",\n    responses=GetTaskController.responses() # (1)\n)\ndef get_task(task_id: UUID) -&gt; Task: # (2)\n    result = GetTaskController()\n    return as_fastapi(result, expected_type=Task)\n</code></pre> <ol> <li>Use <code>responses()</code> method from <code>FastAPIController</code> to get defined error_map in FastAPI format.</li> <li>Define return Model.</li> </ol>"},{"location":"extra/rabbitmq/rabbitmq/","title":"RabbitMQ","text":"<pre><code>$ pip install petisco[rabbitmq]\n---&gt; 100%\nSuccessfully installed petisco\n</code></pre> <p>This page is an overview of how petisco helps us on Message Broker development using RabbitMQ as message broker. Currently, petisco provides a RabbitMQ implementation on top of pika framework.</p>"},{"location":"extra/rabbitmq/rabbitmq/#1-terminology","title":"1. Terminology","text":"<p>This glossary joins domain ubiquitous language with the specific implementation using RabbitMQ.</p> Name Description More Info <code>Publisher</code> Application (or application instance) that publishes messages (e.g domain events and commands). Also called producer. https://www.rabbitmq.com/publishers.html <code>Message Broker</code> Intermediary application that translates a message from the formal messaging protocol of the sender (publisher/producer) to the formal messaging protocol of the receiver (subscriber/consumer). - <code>Exchange</code> \"Messages are not published directly to a queue. Instead, the producer sends messages to an exchange. Exchanges are message routing agents, defined by the virtual host within RabbitMQ. An exchange is responsible for routing the messages to different queues with the help of header attributes, bindings, and routing keys.\" https://www.cloudamqp.com/blog/part4-rabbitmq-for-beginners-exchanges-routing-keys-bindings.html <code>Queue</code> \"A queue is a sequential data structure with two primary operations: an item can be enqueued (added) at the tail and dequeued (consumed) from the head. Queues play a prominent role in the messaging technology space: many messaging protocols and tools assume that publishers and consumers communicate using a queue-like storage mechanism.\" https://www.rabbitmq.com/queues.html <code>Subscriber</code> Application (or application instance) that consumes messages (e.g domain events and commands) from a queue and handles a derived action. Also called consumer or handler. - <p>Find several RabbitMQ tutorials in https://www.rabbitmq.com/getstarted.html.</p> <pre><code>sequenceDiagram\n    participant Publisher\n    participant Exchange\n    participant Queue\n    participant Subscriber\n\n        autonumber\n\n    Publisher-&gt;&gt;Exchange: Message\n    Exchange-&gt;&gt;Queue: Message\n        Note over Exchange,Queue: Based on exchange rules (bindings)\n    Subscriber-&gt;&gt;Queue: Read Message\n    Subscriber--&gt;&gt;Queue: ack\n    Note over Queue: Remove message</code></pre>"},{"location":"extra/rabbitmq/rabbitmq/#2-example","title":"2. Example","text":"<p>In examples/rabbitmq you can find several scripts to interact with RabbitMQ. To test how petisco can help you on message management you need to run locally a RabbitMQ application. </p> <ol> <li>Run RabbitMQ with docker.     <pre><code>docker run -d --rm --name petisco-rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:3-management\n</code></pre>     You can check the RabbitMQ status on http://localhost:15672/#/ (guest:guest). Please,      check the official doc here.</li> <li>Clone the project     <pre><code>git clone git@github.com:alice-biometrics/petisco.git &amp;&amp; cd petisco\n</code></pre></li> <li>Create a python environment and install petisco     <pre><code>&gt; python3 -m venv venv\n&gt; source venv/bin/activate\n(venv) &gt; pip install lume\n(venv) &gt; lume -install\n</code></pre></li> <li>Configure the exchanges and queues. This script will configure common queues and specific queues to support subscriptions (domain event and command consumers/handlers).     <pre><code>python3 examples/rabbitmq/configure.py\n</code></pre></li> <li>Start consuming messages from Queues. This script will execute a continuous process to consume every message on subscribed queues.      <pre><code>python3 examples/rabbitmq/consume.py\n</code></pre></li> <li>Publish domain events.     <pre><code>python3 examples/rabbitmq/publish_domain_events.py\n</code></pre></li> <li>Dispatch commands.     <pre><code>python3 examples/rabbitmq/dispatch_commands.py\n</code></pre></li> </ol> <p>These examples can help you to start playing with rabbitmq and to understand how it works in petisco. It is strongly  recommended to check local rabbitmq at http://localhost:15672/#/ (as mentioned above) to review the activity of queues and exchanges.</p> <p></p> <p>In addition, there are three useful scripts (<code>clear.py</code>, <code>clear_subscribers.py</code>, <code>configure_with_clear_before.py</code>) for  play with queue management and some administration tools for removing or renewing exchanges and queue configurations.</p> <p>If you want to go deeper into how messages are queued in rabbitmq, you can review the concepts of <code>bindings</code>, <code>routing_keys</code> and <code>dead_letters</code>.</p> <p></p>"},{"location":"extra/rabbitmq/rabbitmq/#3-configurations","title":"3. Configurations","text":"<p>Some configurations are managed by the classes and examples seen above, others can be configured with the following  environment variables.</p> <ul> <li><code>RABBITMQ_HEARTBEAT</code>: (default: 60 s)</li> <li><code>RABBITMQ_USER</code>: (default: guest)</li> <li><code>RABBITMQ_PASSWORD</code>: (default: guest)</li> <li><code>RABBITMQ_HOST</code>: (default: localhost)</li> <li><code>RABBITMQ_HOST</code>: (default: 5672)</li> <li><code>RABBITMQ_CONNECTION_NUM_MAX_RETRIES</code>: (default: 15)</li> <li><code>RABBITMQ_CONNECTION_WAIT_SECONDS_RETRY</code>: (default: 1)</li> <li><code>RABBITMQ_MESSAGE_TTL</code>: (default 1000 ms) If a queue is already created it will generate a precodition failure.</li> </ul>"},{"location":"extra/rabbitmq/rabbitmq/#4-cli-tools","title":"4. CLI Tools","text":"<p>Note</p> <p>Since version <code>v1.7.0</code>, petisco have available the cli command <code>petisco-rabbitmq</code> to consume domain events and requeue them.</p> <p>Imagine you have some events in a dead letter queue. To reproduce, you can configure your rabbitmq and publish some  events without launching a consumer. </p> <pre><code>python3 examples/rabbitmq/configure.py\npython3 examples/rabbitmq/publish_domain_events.py\n</code></pre> <p>To requeue event from queues, just use the <code>petisco-rabbitmq</code></p> <pre><code>&gt;&gt; petisco-rabbitmq --help                                                                                                                                \nusage: petisco-rabbitmq \ud83c\udf6a [-h] [-rq] [-cq CONSUMING_QUEUES] [-o ORGANIZATION] [-s SERVICE] [-mr MAX_RETRIES] [-rttl RETRY_TTL] [-wtr WAIT_TO_REQUEUE]\n\npetisco-rabbitmq helps us on rabbitmq iteration\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -rq, --requeue        requeue\n  -o ORGANIZATION, --organization ORGANIZATION\n                        Name of the organization\n  -s SERVICE, --service SERVICE\n                        Name of the service\n  -cq CONSUMING_QUEUE, --consuming-queue CONSUMING_QUEUE\n                        Queue to consume\n  -rrk RETRY_ROUTING_KEY, --retry-routing-key RETRY_ROUTING_KEY\n                        Routing key to republish the message to specific retry queue\n  -ren RETRY_EXCHANGE_NAME, --retry-exchange-name RETRY_EXCHANGE_NAME\n                        Exchange name to republish the message to specific exchange\n  -mr MAX_RETRIES, --max-retries MAX_RETRIES\n                        Max Retries\n  -rttl RETRY_TTL, --retry-ttl RETRY_TTL\n                        Retry TTL\n  -wtr WAIT_TO_REQUEUE, --wait-to-requeue WAIT_TO_REQUEUE\n                        Wait to Requeue (seconds)\n</code></pre> <p>Examples:</p> <ul> <li>Example 1 (requeue events from <code>dead_letter.acme.registration.1.event.user_confirmed.send_sms_on_user_confirmed</code>):     <pre><code>petisco-rabbitmq --requeue \\\n    --organization acme \\\n    --service registration \\\n    --consuming-queue dead_letter.acme.registration.1.event.user_confirmed.send_sms_on_user_confirmed \\\n    --retry-routing-key retry.acme.registration.1.event.user_confirmed.send_sms_on_user_confirmed\n</code></pre></li> <li>Example 2 (requeue events from <code>dead_letter.acme.registration.1.event.user_created.send_mail_on_user_created</code>):     <pre><code>petisco-rabbitmq --requeue \\\n    --organization acme \\\n    --service registration \\\n    --consuming-queue dead_letter.acme.registration.1.event.user_created.send_mail_on_user_created \\\n    --retry-routing-key retry.acme.registration.1.event.user_created.send_mail_on_user_created\n</code></pre></li> </ul> <ul> <li>Example 3 (requeue events from <code>dead_letter.store</code>):     <pre><code>petisco-rabbitmq --requeue \\\n    --organization acme \\\n    --service registration \\\n    --consuming-queue dead_letter.store \\\n    --retry-routing-key retry.store \\\n    --retry-exchange-name retry.acme.store\n</code></pre></li> </ul>"},{"location":"extra/rabbitmq/rabbitmq/#5-code","title":"5. Code","text":"<p>Note</p> <p>Base code is available in petisco/domain/message  and specific implementation in petisco/extra/rabbitmq.</p> <p>Some definition of domain base classes:</p> Name Description Message Define a basic Message using a base metaclass (<code>MetaMessage</code>) DomainEvent Defines a Domain Event inheriting from <code>Message</code>. You can define new attributes to add to the resultant encoded message. Command Defines a Command inheriting from <code>Message</code>. You can define new attributes to add to the resultant encoded message. MessageBus Interface which defines the contract of a message bus to publish messages DomainEventBus Interface which defines the contract of domain event bus to publish <code>DomainEvent</code>. It inherits from <code>MessageBus</code> CommandBus Interface which defines the contract of command bus to dispatch <code>Command</code>. It inherits from <code>MessageBus</code> MessageSubscriber Interface which defines the contract of a subscriber using a base metaclass (<code>MetaMessageSubscriber</code>) DomainEventSubscriber Interface which defines the contract of <code>DomainEvent</code> hanlders. It inherits from <code>MessageSubscriber</code> CommandSubscriber Interface which defines the contract of <code>Command</code> hanlders. It inherits from <code>MessageSubscriber</code> AllMessageSubscriber Interface which defines the contract of every message (e.g <code>DomainEvent</code> and <code>Command</code>) hanlders. It inherits from <code>MessageSubscriber</code> MessageConfigurer Interface which defines the contract of message configurer MessageConsumer Interface which defines the contract of message consumers <p>Some RabbitMQ implementations:</p> Name Description RabbitMqConnector Singleton class to define RabbitMQ connector and set its configurations. RabbitMqDomainEventBus RabbitMQ implementation of <code>DomainEventBus</code> to publish <code>DomainEvents</code>. RabbitMqCommandBus RabbitMQ implementation of <code>CommandBus</code> to dispatch <code>Commands</code>. RabbitMqMessageConfigurer RabbitMQ implementation of <code>MessageConfigurer</code>, which configures exchanges, queue bindings and routing keys from defined <code>MessageSubscribers</code> RabbitMqMessageConsumer RabbitMQ implementation of <code>MessageConsumer</code> to add subscribers, and start a thread to consume message from defined subscribers <pre><code>classDiagram\n        class RabbitMqConnector\n        RabbitMqConnector: +close()\n        RabbitMqConnector: +get_connection()\n        RabbitMqConnector: +get_channel()\n\n        class MessageConfigurer\n        MessageConfigurer: +configure_subscribers()\n        MessageConfigurer: +clear()\n\n        class MessageConsumer\n        MessageConsumer: +add_subscribers()\n        MessageConsumer: +add_subscriber_on_dead_letter()\n        MessageConsumer: +add_subscriber_on_queue()\n        MessageConsumer: +unsubscribe_subscriber_on_queue()\n        MessageConsumer: +resume_subscriber_on_queue()\n        MessageConsumer: +start()\n        MessageConsumer: +stop()\n\n        class MessageSubscriber\n        MessageSubscriber: +subscribed_to()\n        MessageSubscriber: +handle()\n        MessageSubscriber: +set_domain_event_bus()\n        MessageSubscriber: +set_command_bus()\n        MessageSubscriber: -get_subscriber_name()\n        MessageSubscriber: -get_message_subscribers_info()\n\n    class Message\n    Message : +Uuid message_id\n    Message : +str name\n    Message : +int version\n    Message : +datatime oscurred_on\n    Message : +dict attributes (ready to compose) \n    Message : +dict meta (ready to add info id, e.g correlation_id, client_id)\n    Message: +str type\n\n    class MessageBus\n    MessageBus : +publish()\n\n        class DomainEventBus\n    DomainEventBus : +publish()\n\n        class CommandBus\n    CommandBus : +dispatch()\n\n    DomainEvent --|&gt; Message \n    Command --|&gt; Message \n\n    DomainEventBus --|&gt; MessageBus \n    CommandBus --|&gt; MessageBus \n\n    DomainEventBus --* DomainEvent \n    CommandBus --* Command \n    MessageConsumer --* MessageSubscriber \n\n    RabbitMqMessageConfigurer --|&gt; MessageConfigurer\n    RabbitMqMessageConsumer --|&gt; MessageConsumer\n    RabbitMqDomainEventBus --|&gt; DomainEventBus \n    RabbitMqCommandBus --|&gt; CommandBus\n\n    RabbitMqMessageConfigurer --* RabbitMqConnector \n    RabbitMqMessageConsumer --* RabbitMqConnector \n    RabbitMqDomainEventBus --* RabbitMqConnector \n    RabbitMqCommandBus --* RabbitMqConnector </code></pre>"},{"location":"extra/rabbitmq/rabbitmq/#rabbitmq-in-your-application","title":"RabbitMQ in your Application","text":"<p>To add RabbitMQ to your application, you need to define your message dependencies and configure them to start consuming  messages:</p> <pre><code>from petisco.extra.rabbitmq import get_rabbitmq_message_dependencies\n\nORGANIZATION = \"acme\"\nSERVICE = \"my-app\"\n\n# Define RabbitMQ dependencies \ndef dependencies_provider() -&gt; list[Dependency]:\n    ...\n    message_dependencies = get_rabbitmq_message_dependencies(ORGANIZATION, SERVICE)\n    dependencies += message_dependencies\n    ---\n    return dependencies\n\n\nfrom petisco.extra.rabbitmq import RabbitMqConfigurer, DomainEventSubscriber\n\n# Define RabbitMQ configurers  \nclass SendSmsOnUserCreated(DomainEventSubscriber):\n    def subscribed_to(self) -&gt; list[type[DomainEvent]]:\n        return [UserCreated]\n\n    def handle(self, domain_event: UserCreated) -&gt; BoolResult:\n       ## do your stuff\n       return isSuccess\n\nconfigurers = [\n    RabbitMqConfigurer(\n        subscribers=[SendSmsOnUserCreated]\n    )\n]\n\napplication = Application(\n    name=SERVICE,\n    version=\"1.0.0\",\n    organization=ORGANIZATION,\n    deployed_at=str(datetime.utcnow()),\n    environment=\"staging\",\n    dependencies_provider=dependencies_provider,  # &lt;==== Adding dependencies \u2795\n    configurers=configurers # &lt;==== Adding configurers \u2795\n)\napplication.configure()\n</code></pre> <p>This code will start consuming message and calling your defined subscribers for your defined <code>SERVICE</code> (name of your  application). If you want to subscribe to messages from, for example, other service you can do it quite similar using  alias:</p> <pre><code>from petisco.extra.rabbitmq import get_rabbitmq_message_dependencies\n\nORGANIZATION = \"acme\"\nSERVICE = \"my-app\"\nOTHER_SERVICE = \"my-other-app\"\n\n\n# Define RabbitMQ dependencies \ndef dependencies_provider() -&gt; list[Dependency]:\n    ...\n    message_dependencies = get_rabbitmq_message_dependencies(ORGANIZATION, SERVICE)\n    dependencies += message_dependencies\n    ---\n    other_message_dependencies = get_rabbitmq_message_dependencies(\n        ORGANIZATION, \n        OTHER_SERVICE, \n        alias=\"other\"\n    )\n    dependencies += other_message_dependencies\n    return dependencies\n\n\nfrom petisco.extra.rabbitmq import RabbitMqConfigurer, DomainEventSubscriber\n\n# Define RabbitMQ configurers  \nclass SendSmsOnUserCreated(DomainEventSubscriber):\n    def subscribed_to(self) -&gt; list[type[DomainEvent]]:\n        return [UserCreated]\n\n    def handle(self, domain_event: UserCreated) -&gt; BoolResult:\n       ## do your stuff\n       return isSuccess\n\nconfigurers = [\n    RabbitMqConfigurer(\n        subscribers=[SendSmsOnUserCreated]\n    )\n    RabbitMqConfigurer(\n        subscribers=[SendSmsOnUserCreated]\n        configurer_alias=\"other\",\n        consumer_alias=\"other\",\n    )\n]\n\napplication = Application(\n    name=SERVICE,\n    version=\"1.0.0\",\n    organization=ORGANIZATION,\n    deployed_at=str(datetime.utcnow()),\n    environment=\"staging\",\n    dependencies_provider=dependencies_provider,  # &lt;==== Adding dependencies \u2795\n    configurers=configurers # &lt;==== Adding configurers \u2795\n)\napplication.configure()\n</code></pre> <p>With this configuration the application will handle <code>UserCreated</code> message from the main service (<code>SERVICE=my-app</code>) and also from the other service (<code>SERVICE=my-other-app</code>) using the following configurer queues:</p> <ul> <li><code>alice.my_app.1.user_created.send_sms_on_user_created</code>: SendSmsOnUserCreated will handle domain event published by the <code>my_app</code> service.</li> <li><code>alice.my_other_app.1.user_created.send_sms_on_user_created</code>: SendSmsOnUserCreated will handle domain event published by the <code>my_other_\u00barrapp</code> service.</li> </ul> <p>Note</p> <p>Imagine your are consuming from a <code>ORGANIZATION=\"acme\"</code> and <code>SERVICE=\"my-app</code> and you want to publish a derived domain event in your subscriber. You can do it with the inner domain_event_bus (this pre-loaded domain event bus is already configured and shares connection to avoid thread errors)</p> <pre><code>class UserSmailed(DomainEvent): ...\n\nclass SendSmsOnUserCreated(DomainEventSubscriber):\n    def subscribed_to(self) -&gt; list[type[DomainEvent]]:\n        return [UserCreated]\n\n    def handle(self, domain_event: UserCreated) -&gt; BoolResult:\n       self.domain_event_bus.publish(UserSmiled())\n       return isSuccess\n</code></pre> <p>And maybe you don't want to publish to the same exchange <code>acme.my-app</code> (from <code>{ORGANIZATION}.{SERVICE}</code>) and you want to publish to <code>petisco.my-other-service</code>. So you can configure this inner bus using RabbitMqConfigurer parameters:</p> <pre><code>INNER_BUS_ORGANIZATION = \"petisco\"\nINNER_BUS_SERVICE = \"my-other-service\"\n\nconfigurers = [\n    RabbitMqConfigurer(\n        subscribers=[SendSmsOnUserCreated]\n        inner_bus_organization=INNER_BUS_ORGANIZATION,\n        inner_bus_service=INNER_BUS_SERVICE\n    )\n]\n\napplication = Application(\n    name=SERVICE,\n    version=\"1.0.0\",\n    organization=ORGANIZATION,\n    deployed_at=str(datetime.utcnow()),\n    environment=\"staging\",\n    dependencies_provider=dependencies_provider,  # &lt;==== Adding dependencies \u2795\n    configurers=configurers # &lt;==== Adding configurers \u2795\n)\napplication.configure()\n</code></pre>"},{"location":"extra/rabbitmq/rabbitmq/#testing","title":"Testing","text":"<p>Best way to learn how to use petisco to manage messages is with the examples defined above  and reviewing the petisco test suite (check these folders: messages and + rabbitmq) </p> <p>You can run this tests using: <pre><code>lume -test-with-rabbitmq-mysql-and-elastic\n</code></pre></p> <p>Warning</p> <p>Tests checks rabbitmq availability. If a local rabbitmq is not available, some tests will be skipped.  </p>"},{"location":"extra/rabbitmq/rabbitmq/#code-explained","title":"Code explained","text":"<ul> <li>Create a domain event.   Define a <code>DomainEvent</code> in petisco is as easy as:     <pre><code>from petisco import DomainEvent, Uuid\n\nclass UserCreated(DomainEvent):\n    user_id: Uuid\n\ndomain_event = UserCreated(user_id=Uuid.v4())\n</code></pre></li> <li> <p>Configure RabbitMQ.    Now, you can configure a subscriber, for example, we can use the <code>send_mail_handler</code> subscriber from the example below.</p> <pre><code>  from petisco import DomainEvent, MessageSubscriber\n  from petisco.extra.rabbitmq import RabbitMqConnector, RabbitMqMessageConfigurer\n  from meiga import Result, Error, isSuccess, isFailure\n\n  def send_mail_handler(domain_event: DomainEvent) -&gt; Result[bool, Error]:\n    # Do your stuff here\n    return isSuccess # if fails, returns isFailure\n\n  # Define Subscribers\n  domain_event = UserCreated(user_id=Uuid.v4())\n  subscribers = [MessageSubscriber.from_message(domain_event, [send_mail_handler])]  \n\n  # Configure RabbitMQ Infrastructure with defined subscribers\n  connector = RabbitMqConnector()\n  organization = \"acme\"\n  service = \"registration\"\n  configurer = RabbitMqMessageConfigurer(connector, organization, service)\n  configurer.configure_subscribers(subscribers)\n</code></pre> </li> </ul> <ul> <li>Start Consuming DomainEvents from RabbitMQ.   <pre><code>from petisco import MessageSubscriber, DomainEvent\nfrom petisco.extra.rabbitmq import RabbitMqConnector, RabbitMqMessageConsumer\nfrom meiga import Result, Error, isSuccess, isFailure\n\ndef send_mail_handler(event: DomainEvent) -&gt; Result[bool, Error]:\n  # Do your stuff here\n  return isSuccess # if fails, returns isFailure\n\n# Define Subscribers\ndomain_event = UserCreated(user_id=Uuid.v4())\nsubscribers = [MessageSubscriber.from_message(domain_event, [send_mail_handler])]  \n\n# Define RabbitMQ Consumer and start\norganization = \"alice\"\nservice = \"petisco\"\nmax_retries = 5\nconnector = RabbitMqConnector()\nconsumer = RabbitMqMessageConsumer(connector, organization, service, max_retries)\nconsumer.add_subscribers(subscribers)\nconsumer.start()\n</code></pre></li> <li>Publish DomainEvents with the DomainEventBus     <pre><code>from petisco.extra.rabbitmq import RabbitMqConnector, RabbitMqDomainEventBus\n\nconnector = RabbitMqConnector()\norganization = \"alice\"\nservice = \"petisco\"\nbus = RabbitMqDomainEventBus(connector, organization, service)\n\ndomain_event = UserCreated(user_id=Uuid.v4())\n\nbus.publish(domain_event)\n</code></pre></li> </ul>"},{"location":"extra/rabbitmq/rabbitmq/#6-advanced","title":"6. Advanced","text":"<p>Happy path of a message broker is shown in the following diagram.  Let's imagine a new service (<code>registration</code>) which produces domain events and some actions are derived from them  (managed by subscribers).</p> <pre><code>sequenceDiagram\n    participant Publisher\n    participant Exchange\n    participant Queue\n    participant Subscriber\n    Note over Publisher, Subscriber: Registration Example\n\n    autonumber\n\n  Publisher-&gt;&gt;Exchange: UserCreated\n  Exchange-&gt;&gt;Queue: UserCreated\n    Subscriber-&gt;&gt;Queue: Read Message\n    Subscriber-&gt;&gt;Subscriber: Send SMS to user\n  Subscriber--&gt;&gt;Queue: ack\n    Note over Queue: Remove message</code></pre> <p>However, when something is not correct on the subscriber, petisco/rabbitmq infrastructure performs some actions to  retry the execution. This will be the steps: 1. Subscriber read the message from queue (e.g. UserCreated) 2. Subscriber perform derived fails (e.g. send sms message when user is created) 3. As this derived action fails, subscriber returns a <code>nack</code> to the queue. 4. Now, the message is requeued to the <code>retry</code> queue.    * This waits a specific time (ttl) and message will be requeued n times (also configurable). 5. If derived action is not a success, message will be requeue to a <code>dead letter</code> queue.</p> <pre><code>sequenceDiagram\n    participant Publisher\n    participant Exchange\n    participant Queue\n    participant Subscriber\n\n    autonumber\n\n    Publisher-&gt;&gt;Exchange: Message\n    Exchange-&gt;&gt;Queue: Message\n        Note over Exchange,Queue: Based on exchange rules (bindings)\n    Subscriber-&gt;&gt;Queue: Read Message\n\n        loop N TIMES\n                Subscriber-&gt;&gt;Subscriber: Performs derived action\n        Subscriber--&gt;&gt;Retry Queue: nack\n                Note over Retry Queue: Message move to retry queue\n        Retry Queue--&gt;&gt;Retry Queue: Message\n                Note over Retry Queue: Wait Retry TTL\n        Retry Queue--&gt;&gt;Queue: Message\n                Note over Queue: Try again\n    end\n\n        Subscriber--&gt;&gt;Dead Letter Queue: Message\n        Note over Dead Letter Queue: Message move to dead letter queue</code></pre>"},{"location":"extra/rabbitmq/rabbitmq/#queue-naming","title":"Queue Naming","text":"<p>The queues naming uses the following convention:</p> <p><code>&lt;organization&gt;.&lt;service&gt;.&lt;version&gt;.&lt;type&gt;.&lt;event_name&gt;.&lt;action_handler&gt;</code></p> <p>where:</p> <ul> <li>organization is used for represent your company/team/project</li> <li>service is used for represent your service/application</li> <li>version is used for represent the version of the source event/command</li> <li>type is used for represent the type of source that triggers the process (event|command)</li> <li>event_name is used to represent the name of the event in snake case (<code>UserCreate</code> -&gt; <code>user.created</code>) </li> <li>action_handler is used to represent the name of the callback which will trigger the event (e.g <code>send_mail_handler</code>) </li> </ul>"},{"location":"extra/rabbitmq/rabbitmq/#how-petisco-takes-advantage-of-rabbitmq","title":"How petisco takes advantage of RabbitMQ","text":"<p>Continuing with the <code>registration</code> example: imagine we are developing this system for an organization called <code>acme</code>).</p> <p>We want to publish a domain event when the user create an account (<code>UserCreated</code>).  The <code>registration</code> service will react to this event storing the date (metrics are important) and performing some  derived action (e.g <code>send_mail_handler</code>). This event will be consumed by subscribers (derived actions that are executed  from associated events).</p> <p>In our example, we are going to use two subscribers:</p> <ul> <li><code>event_store</code>: general subscriber. It can be useful for saving all domain events.</li> <li><code>send_mail_handler</code>: It will send a mail on <code>UserCreated</code> event.</li> </ul> <p>The following figure represents this use case:</p> <p></p> <p>What is happening here?</p> <ol> <li>The <code>DomainEventBus</code> publishes the <code>UserCreated</code> domain event. <ul> <li>The routing key of this event is <code>acme.registration.1.event.user.created</code> </li> </ul> </li> <li>The exchange <code>acme.registration</code> (.) redirect the message using the binding keys (green) <li>The <code>store</code> queue receives the event perfectly :metal:</li> <li>The <code>acme.registration.1.event.user.created.send_mail_handler</code> queue gets the <code>UserCreated</code> event.</li> <li>The <code>send_mail_handler</code> consumer obtains the event perform the action:<ul> <li>If it is success: perfect, everything works nice and the queue will get an <code>ack</code> :thumbsup:</li> <li>Otherwise, if it is a failure: something is not working as expected or maybe we are suffering from overload. :fire:     * We need to recover from error, let's <code>ack</code> to <code>acme.registration.1.event.user.created.send_mail_handler</code> and requeue the info to the retry exchange (<code>retry.acme.registration</code>).     * We select a number of maximun retries, as well as the time between retries (<code>x-message-ttl</code> on <code>retry.acme.registration.1.event.user.created.send_mail_handler</code>queue)</li> </ul> </li> <li>When the TTL expires on the retry queue, the message will be requeues automatically with the following parameters:<ul> <li>x-dead-letter-exchange: <code>acme.registration</code></li> <li>x-dead-letter-routing-key: <code>acme.registration.1.event.user.created.send_mail_handler</code></li> </ul> </li> <li>Then, the process will return to 2, however in this case, only will be requed to <code>acme.registration.1.event.user.created.send_mail_handler</code> thanks to the additional binding key <code>retry.acme.registration.1.event.user.created.send_mail_handler</code>.</li>"},{"location":"extra/rabbitmq/rabbitmq/#message-chaos","title":"Message Chaos","text":"<p>Info</p> <p>Chaos engineering is the discipline of experimenting on a system in order to build confidence in the system's capability to withstand turbulent conditions in production. Wikipedia</p> <p>Petisco allows you to force errors from the configuration of certain parameters by setting environment variables.</p>"},{"location":"extra/rabbitmq/rabbitmq/#message-bus","title":"Message Bus","text":"<p>You can force fails in message publication in (for example in <code>RabbitMqDomainEventBus</code> and <code>RabbitMqCommandBus</code>).</p> Environment Variable Description Default PETISCO_CHAOS_PERCENTAGE_INVALID_MESSAGE_PUBLICATION Percentage of invalid message publication. Where 1.0 means rejecting all the publishing messages. 0.0 <p>Helps</p> <p>You can configure PETISCO_CHAOS_PERCENTAGE_INVALID_MESSAGE_PUBLICATION=0.1 to force failures in the 10% of the message publication. This is a convinient way of testing if fallback strategy works as expected.</p>"},{"location":"extra/rabbitmq/rabbitmq/#message-consumer","title":"Message Consumer","text":"<p>Warning</p> <p>To be deprecated to use better naming in 2.0.0. Migration work has already stated with <code>ChaosConfig</code> class implementation.</p> <p>You can add a <code>MessageChaos</code> object as collaborator on a <code>RabbitMqConsumer</code>. As example, petisco provides the <code>RabbitMqEventChaos</code> implementation, where configurable parameters are the following:</p> <ul> <li>percentage_simulate_nack: Percentage of simulate nack [0.0 -&gt; 1.0]. Where 1.0 rejects all the event.     - Configurable with <code>EVENT_CHAOS_PERCENTAGE_SIMULATE_NACK</code> envvar.</li> <li>delay_before_even_handler_second: Delay event handler execution for a given number of seconds.     - Configurable with <code>EVENT_CHAOS_DELAY_BEFORE_EVENT_HANDLER_SECONDS</code> envvar.</li> <li>percentage_simulate_failures: Percentage of simulate failures [0.0 -&gt; 1.0]. Where 1.0 simulate always a failure on handlers.     - Configurable with <code>EVENT_CHAOS_PERCENTAGE_SIMULATE_FAILURES</code> envvar.    </li> <li>protected_routing_keys: Routing keys where chaos will not be applied     - Configurable with <code>EVENT_CHAOS_PROTECTED_ROUTING_KEYS</code> envvar (e.g <code>\"dead_letter.store,dl-legacy\"</code>).  </li> </ul>"},{"location":"extra/redis/redis/","title":"Redis","text":"<pre><code>$ pip install petisco[redis]\n---&gt; 100%\nSuccessfully installed petisco\n</code></pre> <p>This page is an overview of how petisco helps us on Message Broker development using Redis as message publishers.</p>"},{"location":"extra/redis/redis/#redisdomaineventbus","title":"RedisDomainEventBus","text":"<p>The <code>RedisDomainEventBus</code> saves with LPUSH published events.</p> <p>Example</p> <pre><code>from petisco.extra.redis import RedisDomainEventBus\nfrom redis.client import Redis    \n\norganization = \"acme\"\nservice = \"petisco\"\nredis = Redis()\n\ndomain_event_bus = RedisDomainEventBus(organization, service, redis)\n</code></pre>"},{"location":"extra/redis/redis/#rediscommandsbus","title":"RedisCommandsBus","text":"<p>The <code>RedisCommandBus</code> saves with LPUSH dispatched commands.</p> <p>Example</p> <pre><code>from petisco.extra.redis import RedisCommandBus\nfrom redis.client import Redis    \n\norganization = \"acme\"\nservice = \"petisco\"\nredis = Redis()\n\ncommand_bus = RedisCommandBus(organization, service, redis)\n</code></pre>"},{"location":"extra/redis/redis/#working-as-a-fallback-of-rabbitmq","title":"Working as a fallback of RabbitMQ","text":"<p>This Redis implementation could be very interesting to work as a fallback of RabbitMQ implementation. This helps to  make the system more reliable by saving in Redis the messages that rabbitmq cannot publish.</p> <pre><code>flowchart TD\n    rabbitmq\n\n  RabbitMqDomainEventBus --&gt; fallback_domain_event\n\n    RabbitMqCommandBus --&gt; fallback_command\n\n    RabbitMqDomainEventBus -..-&gt; rabbitmq\n    RabbitMqCommandBus -..-&gt; rabbitmq\n\n\n    subgraph fallback_domain_event[fallback]\n    RedisDomainEventBus\n    end\n\n    subgraph fallback_command[fallback]\n    RedisCommandBus\n    end\n\n    subgraph redis\n    domain.events\n    commands\n    end\n\n    RedisDomainEventBus --&gt; domain.events\n    RedisCommandBus --&gt; commands\n\n    cronjob(cronjob)\n    domain.events -..-&gt; cronjob\n    commands -..-&gt; cronjob\n\n    cronjob -. republish/dispatch .-&gt; rabbitmq</code></pre> <p>Example</p> <pre><code>from petisco.extra.rabbitmq import RabbitMqDomainEventBus, RabbitMqCommandBus\nfrom petisco.extra.redis import RedisDomainEventBus, RedisCommandBus\nfrom redis.client import Redis    \n\norganization = \"acme\"\nservice = \"petisco\"\n\n# Redis\nredis = Redis()\nfallback_domain_event_bus = RedisDomainEventBus(organization, service, redis)\nfallback_command_bus = RedisCommandBus(organization, service, redis)\n\n# RabbitMq\nrabbitmq_connector = RabbitMqConnector()\ndomain_event_bus = RabbitMqDomainEventBus(organization, service, rabbitmq_connector, fallback=fallback_domain_event_bus)\ncommand_bus = RabbitMqCommandBus(organization, service, rabbitmq_connector, fallback=fallback_command_bus)\n</code></pre>"},{"location":"extra/slack/slack/","title":"Slack","text":"<p>Warning</p> <p>Page under construction</p> <ul> <li><code>SlackNotifier</code></li> </ul>"},{"location":"extra/sqlalchemy/sqlalchemy/","title":"SQLAlchemy","text":"<p>The <code>SqlDatabase</code> is an specific implementation of a <code>Database</code> using a modern version of the SQLAlchemy ORM (version 2). This object encapsulates some specific SQLAlchemy stuff (e.g engine) and provides it as a scoped session to work with the defined models</p>"},{"location":"extra/sqlalchemy/sqlalchemy/#connections","title":"Connections","text":"<p>When you define a <code>SqlDatabase</code> you have to specify the connection. Petisco already provides connections to <code>MySQL</code> and <code>SQLite</code>, but you can extend it with your requirements.</p> <pre><code>from petisco.extra.sqlalchemy import MySqlConnection, SqlDatabase, SqliteConnection\n\n...\n\nif SQL_SERVER == \"SQLite\"\n  connection = SqliteConnection.create(\"sqlite\", \"database.db\") \nelse:\n  connection = MySqlConnection.from_environ() \n\nsql_database = SqlDatabase(name=\"petisco\", connection=connection) \n</code></pre>"},{"location":"extra/sqlalchemy/sqlalchemy/#models","title":"Models","text":"<p>To define your models, you have to inherit from <code>SqlBase</code> abstract object. Check the following example:</p> <pre><code>from petisco.extra.sqlalchemy import SqlBase\nfrom sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import Mapped\n\nclass SqlUser(SqlBase):\n    __tablename__ = \"User\"\n\n    id: Mapped[int] = Column(Integer, primary_key=True)\n\n    name: Mapped[str] = Column(String(30))\n    age: Mapped[int] = Column(Integer)\n</code></pre> <p>Thanks to inheriting from <code>SqlBase</code> with have available abstract methods ready to be implemented to convert <code>SQL</code> models to domain model and vice versa.</p> <pre><code>from petisco.extra.sqlalchemy import SqlBase\nfrom pydantic import BaseModel\nfrom sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import Mapped\n\n# Domain Model (pydantic)\nclass User(BaseModel):\n    name: str\n    age: int | None\n\n# SQL Model (petisco)\nclass SqlUser(SqlBase):\n    __tablename__ = \"users\"\n\n    id: Mapped[int] = Column(Integer, primary_key=True)\n\n    name: Mapped[str] = Column(String(30))\n    age: Mapped[int] = Column(Integer)\n\n    def to_domain(self) -&gt; User:\n        return User(name=self.name, age=self.age)\n\n    @staticmethod\n    def from_domain(domain_entity: User) -&gt; \"SQLUser\":\n        return SQLUser(name=domain_entity.name, age=domain_entity.age)\n</code></pre> <p>Help</p> <p>You can check the <code>petisco-dev --sql-models</code> cli tool to check which SQL models (inheriting from <code>SQLBase</code>) are available.</p> <p>Warning</p> <p>Consider that your defined models have to inherit from <code>SqlBase</code>. This <code>sqlalchemy.orm.DeclarativeBase</code> will be used to gather all the models and create them in case of the database is empty.</p> <p>When you initialize the <code>SqlDatabase</code> object, a default parameter is given (<code>SqlBase</code>). This given base will be used to create all tables if required.</p> <pre><code>def initialize(self, base: DeclarativeBase = SqlBase) -&gt; None:\n    engine = create_engine(\n        self.connection.url,\n        json_serializer=lambda obj: obj,\n        json_deserializer=lambda obj: obj,\n        echo=self.print_sql_statements,\n    )\n\n    if not database_exists(engine.url):\n        create_database(engine.url)\n        base.metadata.create_all(engine)\n        self._run_initial_statements(engine)\n\n    self.session_factory = sessionmaker(bind=engine)\n</code></pre> <p>Advaced Usage: </p> <p>If you don't want to inherit from <code>SqlBase</code> and want to extend declarative, you can do it creating your base inheriting from <code>DeclarativeBase</code> and passing this to the <code>initialize</code> method.</p> <pre><code>from sqlalchemy.orm import DeclarativeBase\n\nclass YourBaseExtension(DeclarativeBase):\n  # your extension code\n\nclass User(YourBaseExtension):\n    __tablename__ = \"users\"\n\n    id: Mapped[int] = Column(Integer, primary_key=True)\n\n    name: Mapped[str] = Column(String(30))\n    age: Mapped[int] = Column(Integer)\n\nconnection = SqliteConnection.create(\"sqlite\", \"database.db\")\nsql_database = SqlDatabase(name=\"petisco\", connection=connection) \nsql_database.initializes(base=YourBaseExtension)\n</code></pre>"},{"location":"extra/sqlalchemy/sqlalchemy/#session","title":"Session","text":"<p>The <code>SQLDatabase</code> implements the <code>get_session_scope</code> method to get a context manager with a pre-configured  <code>sqlalchemy.orm.Session</code>.</p> <pre><code>session_scope = sql_database.get_session_scope()\nwith session_scope() as session:\n    sql_user = SQLUser(name=\"Alice\", age=3)\n    session.add(sql_user)\n</code></pre> <p>To illustrate what is done in this context manager, you can check the session scope provider:</p> <pre><code>def sql_session_scope_provider(\n    session_factory: Callable[[], Session]\n) -&gt; Callable[[], ContextManager[Session]]:\n    @contextmanager\n    def session_scope() -&gt; ContextManager[Session]:\n        session = session_factory()\n        try:\n            yield session\n            session.commit()\n        except OperationalError as e:\n            logger.error(e)\n            session.rollback()\n            raise e\n        except Exception as e:\n            logger.error(e)\n            session.rollback()\n            raise e\n        finally:\n            session.close()\n    return session_scope\n</code></pre> <p>Note that in this scope, session <code>commit</code> and <code>rollback</code> are taken into account to ease the way we develop, keeping the security aspect.</p>"},{"location":"extra/sqlalchemy/sqlalchemy/#sqlexecutor","title":"SqlExecutor","text":"<p>The <code>SqlExecutor</code> provides us a way to quickly execute SQL statements.</p> <pre><code>from petisco.extra.sqlalchemy import SqlExecutor\n\nsession_scope = sql_database.get_session_scope()\nsql_executor = SqlExecutor(session_scope)\n\n# 1 SQL statmenet\nsql_executor.execute_statement(\n    'INSERT INTO User (name,age) VALUES (\"Alice\",3)'\n)\n\n# 2 SQL several statmenets\nsql_executor.execute_statements(\n    [\n    'INSERT INTO User (name,age) VALUES (\"Alice\",3)',\n    'INSERT INTO User (name,age) VALUES (\"Bob\",10)'\n    ]\n)\n\n# 3 SQL statmenets from filename\nsql_executor.execute_from_filename(\"insert_users.sql\")\n</code></pre> <p>Tip</p> <p>When declare a <code>SqlDatabase</code> you can define a <code>initial_statements_filename</code> to run some SQL statements right after initialization.</p> <pre><code>sql_database = SqlDatabase(\n    name=\"petisco\", \n    connection=connection, \n    initial_statements_filename=\"sql_statements.sql\"\n) \n</code></pre> <p>You can also define some callables before and after the initial statemenents execution with  <code>before_initial_statements</code> and <code>after_initial_statements</code>.</p> <pre><code>def run_alembic() -&gt; None:\n    # add your alembic script\n\ndef do_whatever_after_sql_initial_stements() -&gt; None:\n   # add your stuff\n\nsql_database = SqlDatabase(\n    name=\"petisco\", \n    connection=connection, \n    before_initial_statements=run_alembic,\n    initial_statements_filename=\"sql_statements.sql\",\n    after_initial_statements=do_whatever_after_sql_initial_stements,\n) \n</code></pre>"},{"location":"extra/sqlalchemy/sqlalchemy/#examples","title":"Examples","text":""},{"location":"extra/sqlalchemy/sqlalchemy/#sync","title":"Sync","text":"<p>You can check the following example, and execute it with:</p> <pre><code>cd examples/persistence\npython run_sql_database.py\n</code></pre> examples/persistence/run_sql_database.py<pre><code>from __future__ import annotations\n\nimport os\n\nfrom sqlalchemy import select\n\nfrom examples.persistence.models.sql_user import SqlUser\nfrom petisco import databases\nfrom petisco.extra.sqlalchemy import SqlDatabase, SqliteConnection\n\n# Initialization\nROOT_PATH = os.path.abspath(os.path.dirname(__file__))\nDATABASE_NAME = \"my-database\"\nDATABASE_FILENAME = \"sqlite.db\"\nSERVER_NAME = \"sqlite\"\n\n\ndef database_configurer() -&gt; None:\n    sql_database = SqlDatabase(\n        alias=DATABASE_NAME,\n        connection=SqliteConnection.create(SERVER_NAME, DATABASE_FILENAME),\n    )\n    databases.add(sql_database)\n    databases.initialize()\n\n\ndef execution() -&gt; None:\n    session_scope = databases.get(SqlDatabase, alias=DATABASE_NAME).get_session_scope()\n\n    with session_scope() as session:\n        stmt = select(SqlUser)\n        users = session.execute(stmt).all()\n        print(f\"{users=}\")\n\n        session.add(SqlUser(name=\"Alice\", age=\"3\"))\n        session.add(SqlUser(name=\"Bob\", age=\"10\"))\n        session.commit()\n\n        stmt = select(SqlUser).where(SqlUser.name == \"Alice\")\n        user = session.execute(stmt).fetchone()\n        print(f\"{user=}\")\n\n        stmt = select(SqlUser)\n        users = session.execute(stmt).all()\n        print(f\"{users=}\")\n\n\ndatabase_configurer()\nexecution()\n</code></pre> <p>Where <code>examples/persistence/models/sql_user.py</code> is:</p> examples/persistence/models/sql_user.py<pre><code>from pydantic import BaseModel\nfrom sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import Mapped\n\nfrom petisco.extra.sqlalchemy import SqlBase\n\n\nclass User(BaseModel):\n    name: str\n    age: int | None\n\n\nclass SqlUser(SqlBase[User]):\n    __tablename__ = \"users\"\n\n    id: Mapped[int] = Column(Integer, primary_key=True)\n    name: Mapped[str] = Column(String(30))\n    age: Mapped[int] = Column(Integer)\n\n    def to_domain(self) -&gt; User:\n        return User(name=self.name, age=self.age)\n\n    @staticmethod\n    def from_domain(domain_entity: User) -&gt; \"SqlUser\":\n        return SqlUser(name=domain_entity.name, age=domain_entity.age)\n</code></pre>"},{"location":"extra/sqlalchemy/sqlalchemy/#async","title":"Async","text":"<p>Petisco also provides an async implementation, the <code>AsyncSqlDatabase</code>. To run it with async/await pattern, you could run the following commands</p> <pre><code>cd examples/persistence\npython run_async_sql_database.py\n</code></pre> <p>Where <code>examples/persistence/run_async_sql_database.py</code> is:</p> examples/persistence/run_async_sql_database.py<pre><code>import asyncio\nimport os\n\nfrom sqlalchemy import select\n\nfrom examples.persistence.models import SqlUser\nfrom petisco import databases\nfrom petisco.extra.sqlalchemy import AsyncSqlDatabase, SqliteConnection\n\nROOT_PATH = os.path.abspath(os.path.dirname(__file__))\nDATABASE_NAME = \"my-database\"\nDATABASE_FILENAME = \"sqlite.db\"\nSERVER_NAME = \"sqlite+aiosqlite\"\n\n\nasync def database_configurer() -&gt; None:\n    sql_database = AsyncSqlDatabase(\n        alias=DATABASE_NAME,\n        connection=SqliteConnection.create(SERVER_NAME, DATABASE_FILENAME),\n    )\n    databases.add(sql_database)\n    await databases.async_initialize()\n\n\nasync def execution() -&gt; None:\n    session_scope = databases.get(\n        AsyncSqlDatabase, alias=DATABASE_NAME\n    ).get_session_scope()\n\n    async with session_scope() as session:\n        stmt = select(SqlUser)\n        users = (await session.execute(stmt)).all()\n        print(f\"{users=}\")\n\n        session.add(SqlUser(name=\"Alice\", age=\"3\"))\n        session.add(SqlUser(name=\"Bob\", age=\"10\"))\n        await session.commit()\n\n        stmt = select(SqlUser).where(SqlUser.name == \"Alice\")\n        user = (await session.execute(stmt)).first()\n        print(user)\n\n        stmt = select(SqlUser)\n        users = (await session.execute(stmt)).all()\n        print(f\"{users=}\")\n\n\nasync def main() -&gt; None:\n    await database_configurer()\n    await execution()\n\n\nloop = asyncio.get_event_loop()\nloop.run_until_complete(main())\n</code></pre>"},{"location":"extra/sqlalchemy/sqlalchemy/#async_1","title":"Async","text":"<p>Create two databases modifying using two <code>DeclarativeBase</code>.</p> <pre><code>cd examples/persistence\npython run_two_sql_databases.py\n</code></pre> examples/persistence/run_two_sql_databases.py<pre><code>from __future__ import annotations\n\nimport os\n\nfrom sqlalchemy import select\n\nfrom examples.persistence.models.sql_profession import SqlProfession, AlternativeSqlBase\nfrom examples.persistence.models.sql_user import SqlUser\nfrom petisco import databases\nfrom petisco.extra.sqlalchemy import SqlDatabase, SqliteConnection\n\n\n# Initialization\nROOT_PATH = os.path.abspath(os.path.dirname(__file__))\nDATABASE_NAME_1 = \"my-database-1\"\nDATABASE_FILENAME_1 = \"sqlite_1.db\"\nDATABASE_NAME_2 = \"my-database-2\"\nDATABASE_FILENAME_2 = \"sqlite_2.db\"\n\nSERVER_NAME = \"sqlite\"\n\n\ndef databases_configurer() -&gt; None:\n    sql_database_1 = SqlDatabase(\n        alias=DATABASE_NAME_1,\n        connection=SqliteConnection.create(SERVER_NAME, DATABASE_FILENAME_1),\n    )\n    sql_database_2 = SqlDatabase(\n        alias=DATABASE_NAME_2,\n        connection=SqliteConnection.create(SERVER_NAME, DATABASE_FILENAME_2),\n    )\n    databases.add(sql_database_1)\n    databases.add(sql_database_2)\n\n    databases.initialize(initialization_arguments={DATABASE_NAME_2: {\"base\": AlternativeSqlBase}})\n\n\ndef execution() -&gt; None:\n    session_scope_1 = databases.get(SqlDatabase, alias=DATABASE_NAME_1).get_session_scope()\n\n    with session_scope_1() as session:\n        stmt = select(SqlUser)\n        users = session.execute(stmt).all()\n        print(f\"{users=}\")\n\n        session.add(SqlUser(name=\"Alice\", age=\"3\"))\n        session.add(SqlUser(name=\"Bob\", age=\"10\"))\n        session.commit()\n\n        stmt = select(SqlUser).where(SqlUser.name == \"Alice\")\n        user = session.execute(stmt).fetchone()\n        print(f\"{user=}\")\n\n        stmt = select(SqlUser)\n        users = session.execute(stmt).all()\n        print(f\"{users=}\")\n\n    session_scope_2 = databases.get(SqlDatabase, alias=DATABASE_NAME_2).get_session_scope()\n\n    with session_scope_2() as session:\n        stmt = select(SqlProfession)\n        professions = session.execute(stmt).all()\n        print(f\"{professions=}\")\n\n        session.add(SqlProfession(name=\"Alice\", salary=\"1000\"))\n        session.add(SqlProfession(name=\"Bob\", salary=\"2000\"))\n        session.commit()\n\n        stmt = select(SqlProfession).where(SqlProfession.name == \"Alice\")\n        profession = session.execute(stmt).fetchone()\n        print(f\"{profession=}\")\n\n        stmt = select(SqlProfession)\n        professions = session.execute(stmt).all()\n        print(f\"{professions=}\")\n\n\ndatabases_configurer()\nexecution()\n</code></pre> <p>Where <code>AlternativeSqlBase</code> is defined in <code>examples/persistence/models/sql_profession.py</code> in order to gather other  SQLAlchemy models.</p> examples/persistence/models/sql_profession.py<pre><code>import inspect\nfrom abc import abstractmethod\nfrom typing import Generic, TypeVar\n\nfrom pydantic import BaseModel\nfrom sqlalchemy.orm import Mapped, DeclarativeBase\nfrom sqlalchemy import Column, Integer, String\n\n\nclass User(BaseModel):\n    name: str\n    age: int | None\n\n\nT = TypeVar(\"T\")\n\n\nclass AlternativeSqlBase(DeclarativeBase, Generic[T]):\n    def __repr__(self) -&gt; str:\n        attributes = \", \".join(\n            f\"{key}={value}\"\n            for key, value in self.__dict__.items()\n            if not key.startswith(\"_\")\n        )\n        return f\"{self.__class__.__name__}({attributes})\"\n\n    def info(self) -&gt; dict[str, str]:\n        return {\n            \"name\": self.__class__.__name__,\n            \"module\": self.__class__.__module__,\n            \"file\": inspect.getsourcefile(self.__class__),\n        }\n\n    @abstractmethod\n    def to_domain(self) -&gt; T:\n        pass\n\n    @staticmethod\n    @abstractmethod\n    def from_domain(domain_entity: T) -&gt; \"AlternativeSqlBase\":\n        pass\n\n\nclass Profession(BaseModel):\n    name: str\n    salary: int\n\n\nclass SqlProfession(AlternativeSqlBase[Profession]):\n    __tablename__ = \"professions\"\n\n    id: Mapped[int] = Column(Integer, primary_key=True)\n\n    name: Mapped[str] = Column(String(30))\n    salary: Mapped[int] = Column(Integer)\n\n    def to_domain(self) -&gt; Profession:\n        return Profession(name=self.name, salary=self.salary)\n\n    @staticmethod\n    def from_domain(domain_entity: User) -&gt; \"SqlProfession\":\n        return SqlProfession(name=domain_entity.name, salary=domain_entity.salary)\n</code></pre>"},{"location":"migrations/from_v1_to_v2/","title":"From v1 to v2","text":"<p>Here, you will find comprehensive information and guidelines on migrating to a new version (v2) of petisco framework.  Upgrading to the latest version can bring numerous benefits, including enhanced features, improved performance, and  increased security. However, we understand that the migration process can be complex and challenging, which is why we  have compiled this documentation to assist you every step of the way.</p>"},{"location":"migrations/from_v1_to_v2/#breaking-changes","title":"Breaking Changes","text":"<p>Following changes may require modifications to your existing code. While we apologize for any inconvenience, we believe  these updates will enhance functionality and improve user experience. Please review the accompanying documentation for  specific modifications and reach out to our support team for assistance. We value your feedback and appreciate your  understanding during this transition. Thank you for your continued support as we strive to provide you with an improved  library experience.</p>"},{"location":"migrations/from_v1_to_v2/#dependencies","title":"Dependencies","text":"<p>Warning</p> <p>On dependency definition, <code>name</code> and <code>default_builder</code> are no longer available. </p> Petisco v1 \ud83d\udc74Petisco v2 \ud83d\udc76 <pre><code>from petisco import Container, Dependency\n\ndependencies = [\n    Dependency(name=\"my-base\", default_builder=Builder(MyImplementation))\n]    \nContainer.set_dependencies(dependencies)\n\ninstance = Container.get(\"my-base\")\n</code></pre> <pre><code>from petisco import Container, Dependency\n\ndependencies = [\n    Dependency(MyBase, builders={\"default\": Builder(MyImplementation)})\n]    \nContainer.set_dependencies(dependencies)\n\ninstance = Container.get(MyBase)\n</code></pre> <p>For more info about new way of defining dependencies, you can check the Dependency Injection Container section.</p>"},{"location":"migrations/from_v1_to_v2/#controller-result","title":"Controller Result","text":"<p>Warning</p> <p>After some attempts to remove the forbidden petisco magic behind the controller returning type while keeping the useful mapping of the result (e.g. mapping Result values to outputs or Http errors in FastAPI) like in the Issue 333 , a new proposal have been validated.</p> <p>The main idea is simplify controller result to avoid the following question: Is petisco controller going to return  me a <code>meiga.Result</code> or instead is going to directly map the Result using the Controller Config parameters (See Doc).?</p> <p>Now, the <code>Controller</code> implementation of petisco v2 version always returns a <code>meiga.Result</code> type. And this Result  type will have set a tranformed function to map domain result to the framework expected result (e.g. agging mapping  Result values to outputs or Http errors in FastAPI).</p> Petisco v1 \ud83d\udc74Petisco v2 \ud83d\udc76 <pre><code>from petisco import DomainError, Controller, PrintMiddleware\nfrom meiga import Result, Success, Error\nimport random\n\nclass MyError(DomainError): ...\n\nclass MyController(Controller):\n    class Config:  \n        success_handler = lambda result: {\"message\": \"ok\"}\n        error_map = {NotFound: HttpError(status_code=404, detail=\"Task not Found\")}\n        middlewares = [PrintMiddleware]\n\n    def execute(self) -&gt; Result[bool, Error]:\n        return Success(random.choice([True, False]))\n\nresult = MyController().execute()\n</code></pre> <pre><code>from petisco import DomainError, Controller, PrintMiddleware\nfrom meiga import Result, Success, Error\nimport random\n\nclass MyError(DomainError): ...\n\nclass MyController(Controller):\n    class Config: # \n        success_handler = lambda result: {\"message\": \"ok\"}\n        error_map = {NotFound: HttpError(status_code=404, detail=\"Task not Found\")}\n        middlewares = [PrintMiddleware]\n\n    def execute(self) -&gt; Result[bool, Error]:\n        return Success(random.choice([True, False]))\n\nresult = MyController().execute()\n\n# If you want to transform you can do it with result.transform() o with a better semantic funciton `as_fastapi`\nfrom petisco.extras.fastapi import as_fastapi\nmapped_result = as_fastapi(result)\n</code></pre> <p>To use this in a FastAPI router, is quite easy:</p> Petisco v1 \ud83d\udc74Petisco v2 \ud83d\udc76 <pre><code>from fastapi import APIRouter\n\nrouter = APIRouter()\n@router.get(\"my/path\"):\ndef my_router():\n    result = MyController().execute() # real result don't match with typehint as it is mapped\n    return result\n</code></pre> <pre><code>from fastapi import APIRouter\nfrom petisco.extra.fastapi import as_fastapi\n\nrouter = APIRouter()\n@router.get(\"my/path\"):\ndef my_router():\n    result = MyController().execute()\n    return as_fastapi(result)\n</code></pre>"},{"location":"migrations/from_v1_to_v2/#messagebuses","title":"MessageBuses","text":"<p>Warning</p> <p><code>DomainEventBus</code> and <code>CommandBus</code> do not implement <code>publish_list</code> anymore. Now is necessary to rename it to <code>publish</code>. The new <code>publish</code> implementation available in petisco v2 allows to pass individual and list of messages.</p> Petisco v1 \ud83d\udc74Petisco v2 \ud83d\udc76 <pre><code>from petisco import Container, Dependency\n\ndomain_events = [UserCreated(), UserCompleted()]\n\ndomain_event_bus: DomainEventBus = MyDomainEventBus()  \n\ndomain_event_bus.publish_list(domain_events)\n</code></pre> <pre><code>from petisco import Container, Dependency\n\ndomain_events = [UserCreated(), UserCompleted()]\n\ndomain_event_bus: DomainEventBus = MyDomainEventBus()  \n\ndomain_event_bus.publish(domain_events)\n</code></pre>"},{"location":"migrations/from_v1_to_v2/#message-private-properties","title":"Message Private Properties","text":"<p>Warning</p> <p>Petisco Message classes (<code>DomainEvent</code> and <code>Commnad</code>) had some limitations on version 1. Some <code>protected</code> class  attribute names cannot be chosen as were used to store meta information of the message.</p> <p>For example, you cannot use <code>name</code> attribute in your definition, or <code>version</code>.</p> Petisco v1 \ud83d\udc74 <pre><code>from petisco import DomainEvent\n\nclass UserCreated(DomainEvent):\n    name: str \n    version: int\n</code></pre> <p>Version 2 resolves this issues but needs to break compatibility.</p> <p>Now, the access to private attributes must be performed using a sort of getters.</p> Petisco v1 \ud83d\udc74Petisco v2 \ud83d\udc76 <pre><code>from petisco import DomainEvent\n\nclass UserCreated(DomainEvent):\n    name: str \n    version: int\n\n\nuser_created = UserCreated(name\"Alice\", version=2)\n\nprint(user_created.name) # the given name conflicts with private name attribute\nprint(user_created.version) # the given version conflicts with private version attribute\nprint(user_created.attributes) \nprint(user_created.message_id) \nprint(user_created.ocurred_on) \nprint(user_created.meta) \n</code></pre> <pre><code>from petisco import DomainEvent\n\nclass UserCreated(DomainEvent):\n    name: str \n    version: int\n\n\nuser_created = UserCreated(name\"Alice\", version=2)\n\nprint(user_created.get_message_name()) \nprint(user_created.get_message_version()) \nprint(user_created.get_message_attributes()) \nprint(user_created.get_message_id()) \nprint(user_created.get_message_ocurred_on()) \nprint(user_created.get_message_meta()) \n</code></pre>"},{"location":"migrations/from_v1_to_v2/#message-from-metaclass-to-pydantic","title":"Message (From metaclass to Pydantic)","text":"<p>Warning</p> <p>Petisco <code>Message</code> base class is now a <code>pydantic.BaseModel</code>. This will help on dev experience improvement of  <code>DomainEvent</code> and <code>Command</code> and also validation. https://github.com/alice-biometrics/petisco/issues/360</p> <p>To ilustrate main changes we will use the following <code>DomainEvent</code> definition:</p> <pre><code>from petisco import DomainEvent\n\nclass UserCreated(DomainEvent):\n    name: str\n    age: int\n\nuser_created = UserCreated(name=\"acme\", age=50)\n</code></pre> <p>Main changes:</p> <ul> <li>Serialization<ul> <li>Use <code>.format()</code> instead of <code>.dict()</code> to convert your Message to specific message format.   <pre><code>{'data': {'id': '01d34093-7b7f-43b0-8cdf-557bb377c331', 'type': 'user.created', 'type_message': 'domain_event', 'version': 1, 'occurred_on': '2023-07-17 15:35:03.518701', 'attributes': {'name': 'acme', 'age': 50}, 'meta': {}}}\n</code></pre></li> <li>Use <code>.format_json()</code> instead of <code>.json()</code> to convert your Message to specific message format and convert to str.   <pre><code>\"{'data': {'id': '01d34093-7b7f-43b0-8cdf-557bb377c331', 'type': 'user.created', 'type_message': 'domain_event', 'version': 1, 'occurred_on': '2023-07-17 15:35:03.518701', 'attributes': {'name': 'acme', 'age': 50}, 'meta': {}}}\"\n</code></pre></li> <li>Use <code>.model_dump()</code> (old pydantic <code>.dict()</code>) to get model attributes dictionary:   <pre><code>{'name': 'acme', 'age': 50}\n</code></pre></li> <li>Use <code>.model_dump_json()</code> (old pydantic <code>.json()</code>) to get model attributes dictionary:   <pre><code>\"{'name': 'acme', 'age': 50}\"\n</code></pre></li> </ul> </li> <li>Deserialization<ul> <li>Use <code>.from_format(formatted_message: dict | str | bytes)</code> to convert from specific message format (<code>.format()</code> and <code>.format_json()</code> output). Don't use legacy <code>.from_dict()</code>.</li> </ul> </li> <li> <p>envar_modifier with alias</p> <p>The below dependency will automatically creates a <code>envar_modifier</code> with value <code>USER_REPOSITORY_TYPE</code> <pre><code>Dependency(UserRepository,\n          builders={\n              \"default\": Builder(SqlUserRepository),\n              \"fake\": Builder(FakeUserRepository),\n          },\n      ),\n</code></pre></p> <p>Now, if you uses an alias, envar_modifier will be different as well (in the following case <code>USER_REPOSITORY_ALIAS_DASHBOARD_TYPE</code>)</p> <pre><code>Dependency(UserRepository,\n          alias=\"dashboard\",\n          builders={\n              \"default\": Builder(SqlUserRepository),\n              \"fake\": Builder(FakeUserRepository),\n          },\n      ),\n</code></pre> <p>This allows us to have different configuration for different implementation (different alias)</p> <p>\u26a0\ufe0fCheck your configurations (maybe you have to add <code>_ALIAS_{YOUR_ALIAS}</code> to some env vars)!</p> </li> </ul> <ul> <li>New features thanks to pydantic<ul> <li>Attribute auto-completion</li> <li>Attribute and model validation as we are extending from <code>pydantic.BaseModel</code></li> <li>Automatic serialization </li> </ul> </li> </ul>"},{"location":"migrations/from_v1_to_v2/#dev-experience-improvements","title":"Dev Experience Improvements","text":""},{"location":"migrations/from_v1_to_v2/#retrieved-message-are-better-typed","title":"Retrieved Message are better typed","text":"<p>Info</p> <p>In the Issue 340 is implemented an improvement to access  attributes of retrieved Messages (DomainEvent and Commands).</p> Petisco v1 \ud83d\udc74Petisco v2 \ud83d\udc76 <pre><code>from typing import Type\nfrom meiga import isSuccess\nfrom petisco import DomainEventSubscriber, DomainEvent, Container\n\nclass TaskCreated(DomainEvent):\n    name: str\n\nclass SendNotificationOnTaskModifications(DomainEventSubscriber):\n\n    def subscribed_to(self) -&gt; list[Type[DomainEvent]]:\n        return [TaskCreated] \n\n    def handle(self, domain_event: DomainEvent) -&gt; BoolResult:\n\n        task_name = domain_event.attributes.get(\"name\")\n\n        # Do your stuff here\n\n        return isSuccess\n</code></pre> <pre><code>from typing import Type\nfrom meiga import isSuccess\nfrom petisco import DomainEventSubscriber, DomainEvent, Container\n\nclass TaskCreated(DomainEvent):\n    name: str\n\nclass SendNotificationOnTaskModifications(DomainEventSubscriber):\n\n    def subscribed_to(self) -&gt; list[Type[DomainEvent]]:\n        return [TaskCreated] \n\n    def handle(self, domain_event: TaskCreated) -&gt; BoolResult:\n\n        task_name = domain_event.name # With typehint and autocompletion.\n\n        # Do your stuff here\n\n        return isSuccess\n</code></pre>"},{"location":"migrations/from_v1_to_v2/#async-implementations","title":"Async Implementations","text":"<p>Info</p> <p>Petisco v2 provides async implementation for every base elements. This allows petisco users to migrate step their  use cases, controllers and app services keeping back compatibility with current sync implementations.</p> Petisco v1 \ud83d\udc74 (sync)Petisco v2 \ud83d\udc76 (sync -&gt; no changes)Petisco v2 \ud83d\udc76 (async \u26a1) <pre><code>from meiga import BoolResult\nfrom petisco import Container, DomainEventBus\nfrom petisco.extra.fastapi import FastAPIController\n\nfrom app.src.task.create.application.task_creator import TaskCreator\nfrom app.src.task.shared.domain.task import Task\n\n\nclass CreateTaskController(FastAPIController):\n    def execute(self, task: Task) -&gt; BoolResult:\n        task_creator = TaskCreator(\n            labeler=Container.get(TaskLabeler),\n            repository=Container.get(TaskRepository),\n            domain_event_bus=Container.get(DomainEventBus),\n        )\n        return task_creator.execute(task=task)\n</code></pre> <pre><code>from meiga import BoolResult\nfrom petisco import Container, DomainEventBus\nfrom petisco.extra.fastapi import FastAPIController\n\nfrom app.src.task.create.application.task_creator import TaskCreator\nfrom app.src.task.shared.domain.task import Task\n\n\nclass CreateTaskController(FastAPIController):\n    def execute(self, task: Task) -&gt; BoolResult:\n        task_creator = TaskCreator(\n            labeler=Container.get(TaskLabeler),\n            repository=Container.get(TaskRepository),\n            domain_event_bus=Container.get(DomainEventBus),\n        )\n        return task_creator.execute(task=task)\n</code></pre> <pre><code>from meiga import BoolResult\nfrom petisco import Container, DomainEventBus\nfrom petisco.extra.fastapi import AsyncFastAPIController\n\nfrom app.src.task.create.application.task_creator import AsyncTaskCreator\nfrom app.src.task.shared.domain.task import Task\n\n\nclass CreateTaskController(AsyncFastAPIController):\n    async def execute(self, task: Task) -&gt; BoolResult:\n        task_creator = AsyncTaskCreator(\n            labeler=Container.get(TaskLabeler),\n            repository=Container.get(TaskRepository),\n            domain_event_bus=Container.get(DomainEventBus),\n        )\n        return await task_creator.execute(task=task)\n</code></pre>"},{"location":"migrations/from_v1_to_v2/#use-shared_error_map","title":"Use <code>shared_error_map</code>","text":"<p>Info</p> <p>Petisco v2 provides an implementation for configure shared error maps</p> <p>Check <code>error_map</code> documentation in Application/Configuration to know hot to ease  your error handling.</p>"}]}